(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();class p{constructor(t,e,n,r){this.name=t,this.trickTakingRank=e,this.score=n,this.ttRankAbove=r}toString(){return this.name}toStringShort(){return this.name[0]}static rankEquals(t,e){return t.name===e.name}}class u{constructor(t,e){this.name=t,this.rankForTrumpPreference=e}toString(){return this.name}toStringShort(){return this.name[0]}static suitEquals(t,e){return t.name===e.name}}class m{constructor(t,e,n){this.suit=t,this.rank=e,this.index=n}toString(){return`${this.rank.toString()} of ${this.suit.toString()}`}toStringShort(){return`${this.rank.toStringShort()}${this.suit.toStringShort()}`}nextCardUp(t){const e=this.rank.ttRankAbove,n=this.suit,r=t.filter(s=>u.suitEquals(s.suit,n)&&s.rank.trickTakingRank===e);return r.length!==1&&console.log(`Error in nextCardUp: ${r}`),r[0]}static cardEquals(t,e){return p.rankEquals(t.rank,e.rank)&&u.suitEquals(t.suit,e.suit)}static cardFromIndex(t,e){const n=e.filter(r=>r.index===t);return n.length!==1&&console.log(`Error in cardFromIndex: ${n}`),n[0]}}const I=[...Array.from({length:9},(a,t)=>{const e=t+2;return new p(e!==10?String(e):"T",e,e,e+1)}),new p("J",11,12,12),new p("Q",12,15,13),new p("K",13,18,14),new p("A",14,1,4)],T=[new u("Diamonds",0),new u("Hearts",1),new u("Spades",2),new u("Clubs",3)];class y{constructor(t=4){this.minRank=t,this.cards=[],this.cards=this.getFullPack()}getFullPack(){const t=[];let e=0;for(const n of I)if(!(n.trickTakingRank<this.minRank)){n.name==="A"&&(n.ttRankAbove=this.minRank);for(const r of T){let s=new m(r,n,e);t.push(s),e++}}return t}getCard(t){for(const e of this.getFullPack())if(e.toStringShort()===t)return e;throw new Error(`Failed to locate card: ${t}`)}static shuffle(t){for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}}isEmpty(){return this.cards.length===0}filterOut(t){return this.cards.filter(n=>!t.some(r=>m.cardEquals(n,r)))}get count(){return this.cards.length}}const x=["player","comp1","comp2"];class w{constructor(t,e,n,r,s){this.displayName=t,this.name=e,this.hand=n,this.score=r,this.agent=s}}const S={chooseMove:(a,t)=>{const e=Math.floor(Math.random()*t.length);return t[e]}};class L{constructor(t){this.playerNames=t,this.players=[],this.pack=new y,this.cardsPerHand=12,this.trickInProgress=[],this.penultimateCards=[],this.ladders=this.getStartingLadders(),this.trumpSuit=null,this.currentState="initialiseGame";const e=["player","comp1","comp2"],n=["human",S,S];this.players=t.map((r,s)=>new w(r,e[s],[],0,n[s]));for(const r of t)this.players.push();this.dealerIndex=0,this.currentPlayerIndex=0,this.trickIndex=0,this.trickWinnerPlayerIndex=-1,this.finalTrickWinnerIndex=-1}increment(){switch(this.currentState){case"initialiseGame":this.dealCards(this.pack),this.currentState="playCard";break;case"playCard":this.computerMove();break;case"trickComplete":this.resetTrick();break}}get trickInProgressCards(){return this.trickInProgress.map(([t,e])=>t)}get currentLedSuit(){const t=this.trickInProgressCards;return t.length===0?null:t[0].suit}get legalMoveIndices(){let t;const e=this.currentPlayerHand,n=this.currentLedSuit;return n===null?t=e:(t=e.filter(r=>u.suitEquals(r.suit,n)),t.length===0&&(t=e)),t.map(r=>r.index)}getPlayedCard(t){const e=this.trickInProgress.filter(([r,s])=>s.name===t),n=e.length;return n===1?e[0][0]:(n>1&&console.log(`getPlayedCard error: ${e}`),null)}get currentPlayer(){return this.players[this.currentPlayerIndex]}get currentPlayerHand(){return this.currentPlayer.hand}getStartingLadders(){return["5D","6H","7S","8C"].map(t=>[this.pack.getCard(t),null])}get ladderCards(){return this.ladders.map(([t,e])=>t)}trumpSuitFromLadders(){const t=this.ladderCards,e=Math.min(...t.map(i=>i.rank.trickTakingRank)),n=t.filter(i=>i.rank.trickTakingRank===e);if(n.length===1)return n[0].suit;const r=Math.max(...t.map(i=>i.suit.rankForTrumpPreference)),s=t.filter(i=>i.suit.rankForTrumpPreference===r);if(s.length===1)return s[0].suit;throw new Error("Error determining trump suit")}incrementRungCount(t){}updateLadders(t){let e=this.trickInProgressCards;this.isPenultimateTrick&&(e=e.concat(this.penultimateCards));let n;for(;(n=this.ladderCards.filter(r=>e.filter(s=>m.cardEquals(s,r.nextCardUp(this.pack.getFullPack()))))).length>0;){let r=n[0],s=r.nextCardUp(this.pack.getFullPack());this.ladders=this.ladders.filter(([i,o])=>!m.cardEquals(i,r)),this.ladders.push([s,t]),e=e.filter(i=>m.cardEquals(i,s)),e.push(r),this.incrementRungCount(r.suit)}return e}get isPenultimateTrick(){return this.trickIndex===this.cardsPerHand-2}get isFinalTrick(){return this.trickIndex===this.cardsPerHand-1}get handNotFinished(){return this.players.map(t=>t.hand).some(t=>t.length>0)}computerMove(){const t=this.currentPlayer.agent;if(t==="human"){console.log("Trying to move for a human");return}const e=this.legalMoveIndices,n=t.chooseMove(this,e),r=m.cardFromIndex(n,this.pack.getFullPack());return this.playCard(r)||console.log("Error playing card"),n}resetTrick(){const t=this.trickWinnerPlayerIndex;this.currentPlayerIndex=t,this.updateLadders(t),this.isFinalTrick&&(this.finalTrickWinnerIndex=t),this.trickInProgress=[],this.trickIndex++,this.handNotFinished?this.currentState="playCard":this.currentState="handComplete"}dealCards(t,e=12){const n=this.pack.filterOut(this.ladderCards);y.shuffle(n);for(let r=0;r<e;r++)for(let s=0;s<3;s++){const i=n.pop();i&&this.giveCardToPlayer(s,i)}this.trumpSuit=this.trumpSuitFromLadders()}giveCardToPlayer(t,e){this.players[t].hand.push(e)}getPlayerHand(t){return this.players[t].hand??[]}playCard(t){const e=this.currentPlayer,n=e.hand;if(!n)return!1;const r=n.findIndex(s=>s.rank===t.rank&&s.suit===t.suit);if(r>=0){const[s]=n.splice(r,1);return this.trickInProgress.push([s,e]),!0}return!1}getStateForUI(){return{hands:{comp1:[],player:this.getPlayerHand(0),comp2:[]},trumps:this.trumpSuit,played:Object.fromEntries(x.map(t=>[t,this.getPlayedCard(t)])),game_state:this.currentState,whose_turn:this.currentPlayer.name,getCard:t=>this.pack.getCard(t),playCard:t=>this.playCard(t),increment:()=>{this.increment()},previous:{comp1:null,player:null,comp2:null},ladder:{comp1:[],player:[],comp2:[],neutral:this.ladders.filter(([t,e])=>e===null).map(([t,e])=>t)},scores:{comp1:0,player:0,comp2:0},scores_previous:{comp1:0,player:0,comp2:0},score_details:{},holding_bonus:{comp1:{},player:{},comp2:{}},dead:[],penultimate:[],escalations:-1,hand_number:-1,advance:"C"}}}class v{constructor(t){this.pack=new y,this.state=new L(t),this.state.increment()}getGameState(){return this.state}getGameStateForUI(){return this.state.getStateForUI()}}const b={2:0,3:1,4:2,5:3,6:4,7:5,8:6,9:7,T:8,J:9,Q:10,K:11,A:12},P={S:0,H:1,C:2,D:3},F=72,$=96;function h(a,t){const e=document.createElement("span");e.className="card";const n=a.match(/^([0-9TJQKA])([SHDC])$/);if(n){const[,r,s]=n,i=b[r],o=P[s];e.style.backgroundPosition=`-${i*F}px -${o*$}px`}else e.innerText=a,e.style.background="#ccc";return t&&(e.onclick=()=>t(a)),e}function g(a){const t=document.createElement("span");t.className="suit-icon";const e=a.match(/^([SHDC])$/),n=32;if(e){const[,r]=e,s=P[r];t.style.backgroundPosition=`32px -${s*n}px`}else t.innerText="",t.style.background="#ccc";return t}function H(a){console.log(a);const t=document.getElementById("player-hand"),e=a.hands.player;e.sort((o,c)=>100*(o.suit.rankForTrumpPreference-c.suit.rankForTrumpPreference)+(o.rank.trickTakingRank-c.rank.trickTakingRank)),t.innerHTML="",e.forEach(o=>{t.appendChild(h(o.toStringShort(),c=>a.playCard(a.getCard(c))))}),["player","comp1","comp2"].forEach(o=>{const c=document.getElementById(`played-${o}`);c.innerHTML="";const l=a.played[o];if(l){const d=h(l.toStringShort());d.classList.add("played-card"),c.appendChild(d)}}),["player","comp1","comp2"].forEach(o=>{const c=document.getElementById(`prev-${o}`);c.innerHTML="";const l=a.previous[o];if(l){const d=h(l.toStringShort());d.classList.add("played-card"),c.appendChild(d)}}),["player","comp1","comp2"].forEach(o=>{const c=document.getElementById(`hb-${o}`);c.innerHTML="";const l=a.holding_bonus[o];for(const[d,E]of Object.entries(l))for(let k=0;k<E;k++){const C=g(d);C.classList.add("holding-bonus-icon"),c.appendChild(C)}}),["neutral","player","comp1","comp2"].forEach(o=>{const c=document.getElementById(`ladder-${o}`);c.innerHTML="",a.ladder[o].forEach(l=>{c.appendChild(h(l.toStringShort()))})});const n=document.getElementById("penultimate-display"),r=document.getElementById("dead-display");n.innerHTML="",r.innerHTML="",a.penultimate.forEach(o=>n.appendChild(h(o.toStringShort()))),a.dead.forEach(o=>r.appendChild(h(o.toStringShort()))),document.getElementById("scores").innerText=`You: ${a.scores.player}, comp 1: ${a.scores.comp1}, comp 2: ${a.scores.comp2}`,document.getElementById("scores-previous").innerText=`prev: (You: ${a.scores_previous.player}, comp 1: ${a.scores_previous.comp1}, comp 2: ${a.scores_previous.comp2})`,document.getElementById("escalations").innerText=`Escalations: ${a.escalations} (hand #${a.hand_number})`;const s=document.getElementById("trumps");s.innerHTML="",s.appendChild(g(a.trumps?a.trumps.toStringShort():""));const i=document.getElementById("advance");switch(i.innerHTML="",i.appendChild(g(a.advance)),a.game_state){case"playCard":if(a.whose_turn==="player")break;f(700),a.increment();break;case"trickComplete":f(1700),a.increment();break;case"handComplete":f(3e3),a.increment();break}}async function f(a){await M(a)}function M(a){return new Promise(t=>setTimeout(t,a))}window.onload=()=>{const a=new v(["Andy","Randy1","Randy2"]);H(a.getGameStateForUI())};
