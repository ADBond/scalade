(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}})();class m{constructor(t,e,n,r){this.name=t,this.trickTakingRank=e,this.score=n,this.ttRankAbove=r}toString(){return this.name}toStringShort(){return this.name[0]}static rankEquals(t,e){return t.name===e.name}}class h{constructor(t,e){this.name=t,this.rankForTrumpPreference=e}toString(){return this.name}toStringShort(){return this.name[0]}static suitEquals(t,e){return t.name===e.name}}class u{constructor(t,e,n){this.suit=t,this.rank=e,this.index=n}toString(){return`${this.rank.toString()} of ${this.suit.toString()}`}toStringShort(){return`${this.rank.toStringShort()}${this.suit.toStringShort()}`}nextCardUp(t){const e=this.rank.ttRankAbove,n=this.suit,r=t.filter(s=>h.suitEquals(s.suit,n)&&s.rank.trickTakingRank===e);return r.length!==1&&console.log(`Error in nextCardUp: ${r}`),r[0]}static cardEquals(t,e){return m.rankEquals(t.rank,e.rank)&&h.suitEquals(t.suit,e.suit)}static cardFromIndex(t,e){const n=e.filter(r=>r.index===t);return n.length!==1&&console.log(`Error in cardFromIndex: ${n}`),n[0]}static singleHighestCard(t){const e=Math.max(...t.map(r=>r.rank.trickTakingRank)),n=t.filter(r=>r.rank.trickTakingRank===e);return n.length>1&&console.log(`Too many highest cards: ${n}`),n[0]}}const v=[...Array.from({length:9},(i,t)=>{const e=t+2;return new m(e!==10?String(e):"T",e,e,e+1)}),new m("J",11,12,12),new m("Q",12,15,13),new m("K",13,18,14),new m("A",14,1,4)],T=[new h("Diamonds",0),new h("Hearts",1),new h("Spades",2),new h("Clubs",3)],H=T[0];class y{constructor(t=4){this.minRank=t,this.cards=[],this.reset()}reset(){this.cards=this.getFullPack()}getFullPack(){const t=[];let e=0;for(const n of v)if(!(n.trickTakingRank<this.minRank)){n.name==="A"&&(n.ttRankAbove=this.minRank);for(const r of T){let s=new u(r,n,e);t.push(s),e++}}return t}getCard(t){for(const e of this.getFullPack())if(e.toStringShort()===t)return e;throw new Error(`Failed to locate card: ${t}`)}static shuffle(t){for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}}isEmpty(){return this.cards.length===0}filterOut(t,e){return t.filter(r=>!e.some(s=>u.cardEquals(r,s)))}get count(){return this.cards.length}}const k=["player","comp1","comp2"];class F{constructor(t,e,n,r,s,a){this.displayName=t,this.name=e,this.hand=n,this.score=r,this.agent=s,this.positionIndex=a}}const x={chooseMove:(i,t)=>{const e=Math.floor(Math.random()*t.length);return t[e]}};class L{constructor(t){this.playerNames=t,this.players=[],this.pack=new y,this.cardsPerHand=12,this.trickInProgress=[],this.previousTrick=[],this.groundings=[],this.spoils=[],this.previousSpoils=[],this.currentHandsGroundings=[],this.deadCards=[],this.ladders=this.getStartingLadders(),this.trumpSuit=H,this.currentState="initialiseGame",this.handNumber=0;const e=["player","comp1","comp2"],n=["human",x,x];this.players=t.map((r,s)=>new F(r,e[s],[],0,n[s],s));for(const r of t)this.players.push();this.dealerIndex=0,this.currentPlayerIndex=0,this.trickIndex=0,this.finalTrickWinnerIndex=-1}increment(){switch(this.currentState){case"initialiseGame":this.dealCards(this.pack);break;case"playCard":this.computerMove();break;case"trickComplete":this.resetTrick();break;case"handComplete":this.updateScores(),this.previousSpoils=this.spoils.slice(),this.dealerIndex=this.getNextPlayerIndex(this.dealerIndex),this.dealCards(this.pack);break}}get trickInProgressCards(){return this.trickInProgress.map(([t,e])=>t)}get currentLedSuit(){const t=this.trickInProgressCards;return t.length===0?null:t[0].suit}get legalMoveIndices(){let t;const e=this.currentPlayerHand,n=this.currentLedSuit;return n===null?t=e:(t=e.filter(r=>h.suitEquals(r.suit,n)),t.length===0&&(t=e)),t.map(r=>r.index)}getPlayedCard(t,e){const n=e.filter(([s,a])=>a.name===t),r=n.length;return r===1?n[0][0]:(r>1&&console.log(`getPlayedCard error: ${n}`),null)}get currentPlayer(){return this.players[this.currentPlayerIndex]}get currentPlayerHand(){return this.currentPlayer.hand}get humanHand(){return this.getPlayerHand(0)}get numPlayers(){return this.players.length}getNextPlayerIndex(t){return(t+1)%this.numPlayers}get trickWinnerPlayer(){return this.trickInProgress.filter(([n,r])=>u.cardEquals(n,this.winningCard))[0][1]}getStartingLadders(){return["5D","6H","7S","8C"].map(t=>[this.pack.getCard(t),null])}get ladderCards(){return this.ladders.map(([t,e])=>t)}trumpSuitFromLadders(){const t=this.ladderCards,e=Math.min(...t.map(a=>a.rank.trickTakingRank)),n=t.filter(a=>a.rank.trickTakingRank===e);if(n.length===1)return n[0].suit;const r=Math.max(...t.map(a=>a.suit.rankForTrumpPreference)),s=t.filter(a=>a.suit.rankForTrumpPreference===r);if(s.length===1)return s[0].suit;throw new Error("Error determining trump suit")}incrementRungCount(t){}updateLadders(t){let e=this.trickInProgressCards;this.isPenultimateTrick&&(e=e.concat(this.spoils));let n;for(;(n=this.ladderCards.filter(r=>e.filter(s=>u.cardEquals(s,r.nextCardUp(this.pack.getFullPack()))).length>0)).length>0;){let r=n[0],s=r.nextCardUp(this.pack.getFullPack());this.ladders=this.ladders.filter(([a,o])=>!u.cardEquals(a,r)),this.ladders.push([s,t]),e=e.filter(a=>!u.cardEquals(a,s)),e.push(r),this.incrementRungCount(r.suit)}return e}get winningCard(){const t=this.trickInProgress.filter(([n,r])=>h.suitEquals(n.suit,this.trumpSuit));let e;if(t.length>0)e=u.singleHighestCard(t.map(([n,r])=>n));else{const n=this.trickInProgress.filter(([r,s])=>h.suitEquals(r.suit,this.currentLedSuit));e=u.singleHighestCard(n.map(([r,s])=>r))}return e}get isPenultimateTrick(){return this.trickIndex===this.cardsPerHand-2}get isFinalTrick(){return this.trickIndex===this.cardsPerHand-1}get handNotFinished(){return this.players.map(t=>t.hand).some(t=>t.length>0)}get spoilsToDisplay(){return this.isPenultimateTrick&&this.currentState==="trickComplete"||this.isFinalTrick||this.currentState==="handComplete"?this.spoils:this.humanHand.length===this.cardsPerHand?this.previousSpoils:[]}get groundingsToDisplay(){return this.isFinalTrick&&this.currentState==="trickComplete"||this.currentState==="handComplete"?this.deadCards:this.humanHand.length===this.cardsPerHand?this.currentHandsGroundings:[]}computerMove(){const t=this.currentPlayer.agent;if(t==="human")return console.log("Error: trying to move for a human"),-20;const e=this.legalMoveIndices,n=t.chooseMove(this,e),r=u.cardFromIndex(n,this.pack.getFullPack());return this.playCard(r)||console.log("Error playing card"),n}resetTrick(){const t=this.trickWinnerPlayer;this.currentPlayerIndex=t.positionIndex,this.updateLadders(t),this.isFinalTrick&&(this.finalTrickWinnerIndex=t.positionIndex),this.previousTrick=this.trickInProgress,this.trickInProgress=[],this.trickIndex++,this.handNotFinished?this.currentState="playCard":this.currentState="handComplete"}dealCards(t,e=12){const n=Math.ceil(e/2);this.pack.reset();let r=this.pack.filterOut(this.pack.getFullPack(),this.ladderCards);if(y.shuffle(r),this.handNumber===0)for(let s=0;s<2;s++){const a=r.pop();a?this.groundings.push(a):console.log("Deal error! ran out of cards before groundings")}else this.groundings=[...this.deadCards],r=this.pack.filterOut(r,this.groundings);this.currentHandsGroundings=[...this.groundings];for(let s=0;s<e;s++){for(let a=0;a<3;a++){const o=r.pop();o&&this.giveCardToPlayer(a,o)}if(s===n-1){this.deadCards=[];for(let a=0;a<2;a++){const o=r.pop();o?this.deadCards.push(o):console.log("Deal error! ran out of cards before deads")}for(let a=0;a<2;a++){const o=this.groundings.pop();o?r.push(o):console.log("Deal error! ran out of cards before shuffling groundings")}y.shuffle(r)}}this.spoils=[];for(let s=0;s<2;s++){const a=r.pop();a?this.spoils.push(a):console.log("Deal error! ran out of cards before spoils")}console.log("Empty pack:"),console.log([...r]),this.trumpSuit=this.trumpSuitFromLadders(),this.currentState="playCard",this.currentPlayerIndex=this.getNextPlayerIndex(this.dealerIndex),this.handNumber++}giveCardToPlayer(t,e){this.players[t].hand.push(e)}getPlayerHand(t){return this.players[t].hand??[]}playCard(t){if(!this.legalMoveIndices.includes(t.index))return console.log(`Error: Cannot play illegal card ${t}`),!1;const e=this.currentPlayer,n=e.hand;if(!n)return console.log("Error: I couldn't find a hand!"),!1;const r=n.findIndex(o=>o.rank===t.rank&&o.suit===t.suit);if(r<0)return!1;const[s]=n.splice(r,1);if(this.trickInProgress.push([s,e]),this.trickInProgress.length===this.numPlayers)return this.currentState="trickComplete",!0;const a=this.getNextPlayerIndex(this.currentPlayerIndex);return this.currentPlayerIndex=a,!0}updateScores(){}getStateForUI(){return{hands:{comp1:[],player:this.humanHand,comp2:[]},trumps:this.trumpSuit,played:Object.fromEntries(k.map(t=>[t,this.getPlayedCard(t,this.trickInProgress)])),previous:Object.fromEntries(k.map(t=>[t,this.getPlayedCard(t,this.previousTrick)])),ladder:{...Object.fromEntries(k.map(t=>[t,this.ladders.filter(([e,n])=>n!==null&&n.name===t).map(([e,n])=>e)])),neutral:this.ladders.filter(([t,e])=>e===null).map(([t,e])=>t)},penultimate:this.spoilsToDisplay,dead:this.groundingsToDisplay,game_state:this.currentState,whose_turn:this.currentPlayer.name,getCard:t=>this.pack.getCard(t),playCard:t=>(this.playCard(t),this.getStateForUI()),increment:()=>(this.increment(),this.getStateForUI()),hand_number:this.handNumber,scores:{comp1:0,player:0,comp2:0},scores_previous:{comp1:0,player:0,comp2:0},score_details:{},holding_bonus:{comp1:{},player:{},comp2:{}},escalations:-1,advance:"C"}}}class ${constructor(t){this.pack=new y,this.state=new L(t),this.state.increment()}getGameState(){return this.state}getGameStateForUI(){return this.state.getStateForUI()}}const M={2:0,3:1,4:2,5:3,6:4,7:5,8:6,9:7,T:8,J:9,Q:10,K:11,A:12},w={S:0,H:1,C:2,D:3},_=72,R=96;function g(i,t){const e=document.createElement("span");e.className="card";const n=i.match(/^([0-9TJQKA])([SHDC])$/);if(n){const[,r,s]=n,a=M[r],o=w[s];e.style.backgroundPosition=`-${a*_}px -${o*R}px`}else e.innerText=i,e.style.background="#ccc";return t&&(e.onclick=()=>t()),e}function C(i){const t=document.createElement("span");t.className="suit-icon";const e=i.match(/^([SHDC])$/),n=32;if(e){const[,r]=e,s=w[r];t.style.backgroundPosition=`32px -${s*n}px`}else t.innerText="",t.style.background="#ccc";return t}function N(i,t){const e=i.playCard(t);f(e)}async function f(i){console.log(i);const t=document.getElementById("player-hand"),e=i.hands.player;e.sort((c,l)=>100*(c.suit.rankForTrumpPreference-l.suit.rankForTrumpPreference)+(c.rank.trickTakingRank-l.rank.trickTakingRank)),t.innerHTML="",e.forEach(c=>{t.appendChild(g(c.toStringShort(),i.whose_turn==="player"?()=>N(i,c):void 0))}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`played-${c}`);l.innerHTML="";const d=i.played[c],p=g(d!==null?d.toStringShort():"");p.classList.add("played-card"),l.appendChild(p)}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`prev-${c}`);l.innerHTML="";const d=i.previous[c],p=g(d!==null?d.toStringShort():"");p.classList.add("played-card"),l.appendChild(p)}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`hb-${c}`);l.innerHTML="";const d=i.holding_bonus[c];for(const[p,b]of Object.entries(d))for(let I=0;I<b;I++){const E=C(p);E.classList.add("holding-bonus-icon"),l.appendChild(E)}}),["neutral","player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`ladder-${c}`);l.innerHTML="",i.ladder[c].forEach(d=>{l.appendChild(g(d.toStringShort()))})});const n=document.getElementById("penultimate-display"),r=document.getElementById("dead-display");n.innerHTML="",r.innerHTML="",i.penultimate.forEach(c=>n.appendChild(g(c.toStringShort()))),i.dead.forEach(c=>r.appendChild(g(c.toStringShort()))),document.getElementById("scores").innerText=`You: ${i.scores.player}, comp 1: ${i.scores.comp1}, comp 2: ${i.scores.comp2}`,document.getElementById("scores-previous").innerText=`prev: (You: ${i.scores_previous.player}, comp 1: ${i.scores_previous.comp1}, comp 2: ${i.scores_previous.comp2})`,document.getElementById("escalations").innerText=`Escalations: ${i.escalations} (hand #${i.hand_number})`;const s=document.getElementById("trumps");s.innerHTML="",s.appendChild(C(i.trumps?i.trumps.toStringShort():""));const a=document.getElementById("advance");a.innerHTML="",a.appendChild(C(i.advance));let o;switch(i.game_state){case"playCard":if(i.whose_turn==="player")break;await S(700),o=P(i),f(o);break;case"trickComplete":await S(1700),o=P(i),f(o);break;case"handComplete":await S(3e3),o=P(i),f(o);break;default:console.log(`Error: Switching and failing: ${i.game_state}`)}}function S(i){return new Promise(t=>setTimeout(t,i))}function P(i){return i.increment()}window.onload=()=>{const i=new $(["Andy","Randy1","Randy2"]);f(i.getGameStateForUI())};
