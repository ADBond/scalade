import{M as dn,U as hn,N as fn,b as yn,Z as gn,O as Nn,C as bn,R as Tn,e as Sn,T as wn,I as On,V as vn,G as _n,f as An,H as In,h as En,L as kn,i as Cn,j as Dn,k as zn,l as ge,m as Ln,S as Je,n as $n,E as Pn,o as Vn,p as Fn,P as xn,q as Rn,s as jn,t as Bn,u as Hn,v as Wn,w as Un,x as qn,y as Gn,z as Kn,A as Qn,D as Jn,B as Zn,F as Xn,J as Yn,K as Mn,Q as ei,W as ti,X as ai,Y as si,_ as ri,$ as ni,a0 as ii,a1 as oi,a2 as ui,a3 as mi,a4 as pi,a5 as li,a6 as ci,a7 as di,a8 as hi,a9 as fi,aa as yi,ab as gi,ac as Ni,ad as bi,ae as Ti,af as Si,ag as wi,ah as Oi,ai as vi,aj as _i,ak as Ai,al as Ii,am as Ei,an as ki,ao as Ci,ap as Di,aq as zi,ar as Ne,as as Li,at as $i,au as Pi,av as Vi,aw as Fi,ax as xi,ay as Ri,az as ji,aA as Bi,aB as Hi,aC as Wi,aD as Ui,aE as qi,aF as Gi,aG as Ki,aH as Qi,aI as Ji,aJ as Zi,aK as Xi,aL as Yi,aM as Mi,aN as eo,aO as to,aP as be,aQ as Te,aR as ao,aS as so,aT as ro,aU as no,aV as io,aW as oo,aX as uo,aY as mo,aZ as po,a_ as Se,a$ as v,b0 as C,b1 as Ze,b2 as Xe,b3 as Ye,b4 as Me,b5 as et,b6 as tt,b7 as at,b8 as st,b9 as rt,ba as nt,bb as it,bc as ot,bd as ut,be as mt,bf as pt,bg as lt,bh as ct,bi as dt,bj as ht,bk as ft,bl as yt,bm as gt,bn as Nt,bo as bt,bp as Tt,bq as St,br as wt,bs as Ot,bt as vt,bu as we,bv as _t,bw as At,bx as It,by as ee,bz as Et,bA as kt,bB as Ct,bC as Dt,bD as zt,bE as Lt,bF as $t,bG as Pt,bH as Vt,bI as Ft,bJ as xt,bK as Rt,bL as jt,bM as Bt,bN as Ht,bO as Wt,bP as Ut,bQ as qt,bR as Gt,bS as Kt,bT as Qt,bU as Jt,bV as Zt,bW as Xt,bX as Yt,bY as Mt,bZ as ea,b_ as ta,b$ as aa,c0 as sa,c1 as ra,c2 as Oe,c3 as na,c4 as ia,c5 as oa,c6 as ua,c7 as ma,c8 as pa,c9 as la,ca,cb as da,cc as ha,cd as fa,ce as ya,cf as ga,cg as ve,ch as Na,ci as ba,cj as Ta,ck as Sa,cl as wa,cm as Oa,cn as va,co as _a,cp as Aa,cq as Ia,cr as Ea,cs as ka,ct as Ca,cu as Da,cv as za,cw as La,cx as $a,cy as Pa,cz as Va,cA as Fa,cB as xa,cC as Ra,cD as ja,cE as Ba,cF as Ha,cG as Wa,cH as Ua,cI as qa,cJ as Ga,cK as Ka,cL as Qa,cM as Ja,cN as Za,cO as Xa,cP as Ya,cQ as Ma,cR as es,cS as ts,cT as as,cU as ss,cV as rs,cW as ns,cX as is,cY as os,cZ as us,c_ as ms,c$ as ps,d0 as ls,d1 as cs,d2 as ds,d3 as hs,d4 as fs,d5 as ys,d6 as gs,d7 as Ns,d8 as bs,d9 as Ts,da as Ss,db as ws,dc as Os,dd as vs,de as _s,df as As,dg as Is,dh as Es,di as ks,dj as Cs,dk as Ds,dl as zs,dm as Ls,dn as $s,dp as A,dq as Ps,dr as Vs,ds as Fs,dt as xs,du as Rs,dv as js,dw as Bs,dx as Hs,dy as $,dz as Ws,dA as Us,dB as qs,dC as Gs,dD as Ks,dE as Qs,dF as Js,dG as Zs,dH as Xs,dI as Ys,dJ as te,dK as Ms,dL as er,dM as tr,dN as ar,dO as sr,dP as rr,dQ as nr,dR as ir,dS as or,dT as ur,dU as mr,dV as pr,dW as lr,dX as cr,dY as dr,dZ as R,d_ as hr,d$ as fr,e0 as yr,e1 as gr,e2 as Nr,e3 as br,e4 as Tr,e5 as V,e6 as _e,e7 as Z,e8 as Sr,e9 as wr,ea as Or,eb as vr,ec as _r,ed as Ar,ee as Ir,ef as Er,eg as kr,eh as Cr,ei as Dr,ej as j,ek as zr,el as Lr,em as $r,en as Pr,eo as Vr,ep as Fr,eq as k,er as E,es as I,et as Ve,eu as X,ev as Ae,ew as lo,ex as ne,ey as xr,ez as co,eA as ho,eB as Fe,eC as Ie,eD as ae,eE as fo,eF as yo,eG as Rr,eH as go,eI as jr,eJ as Br,eK as No,eL as bo,eM as Hr,eN as Wr,eO as To,eP as So,eQ as wo,eR as Oo,eS as vo,eT as _o,eU as Ao,eV as Io,eW as Eo,eX as ko,eY as Co,eZ as Do,e_ as zo,e$ as Lo,f0 as $o,f1 as Po,f2 as Vo,f3 as Fo,f4 as xo,f5 as Ro,f6 as jo,f7 as Bo,f8 as Ho,f9 as Wo,fa as Uo,fb as qo,fc as Go,fd as Ko,fe as Qo,ff as Jo,fg as Zo,fh as Xo,fi as Yo,fj as Mo,fk as eu,fl as tu,fm as au,fn as su,fo as ru,fp as nu,fq as iu,fr as ou,fs as uu,ft as mu,fu as pu,fv as lu,fw as cu,fx as du,fy as hu,fz as fu,fA as yu,fB as gu,fC as Nu,fD as bu,fE as Tu,fF as Su,fG as wu,fH as Ou,fI as vu,fJ as _u,fK as Au,fL as Iu,fM as Eu,fN as ku,fO as Cu,fP as Du,fQ as zu,fR as Lu,fS as $u,fT as Pu,fU as Vu,fV as Fu,fW as xu,fX as Ru,fY as ju,fZ as Bu,f_ as Hu,f$ as Wu,g0 as Uu,g1 as qu,g2 as Gu,g3 as Ku,g4 as Qu,g5 as Ju,g6 as Zu,g7 as Xu,g8 as Yu,g9 as Mu,ga as em,gb as tm,gc as am,gd as sm,ge as rm,gf as nm,gg as im,gh as om,gi as um,gj as mm,gk as pm,gl as lm,gm as cm,gn as dm,go as hm,gp as fm,gq as ym,gr as gm,gs as Nm,gt as bm,gu as Tm,gv as Sm,gw as wm,gx as Om,gy as vm,gz as _m,gA as Am,gB as Im,gC as Em,gD as km,gE as Cm,gF as Dm,gG as zm,gH as Lm,gI as $m,gJ as Pm,gK as Vm,gL as Fm,gM as xm,gN as Rm,gO as jm,gP as Bm,gQ as Hm,gR as Wm,gS as Um,gT as qm,gU as Gm,gV as Km,gW as Qm,gX as Jm,gY as Zm,gZ as Xm,g_ as Ym,g$ as Mm,h0 as ep,h1 as tp,h2 as ap,h3 as sp,h4 as rp,h5 as np,h6 as ip,h7 as op,h8 as up,h9 as mp,ha as pp,hb as lp,hc as cp,hd as dp,he as hp,hf as fp,hg as yp,hh as gp,hi as Np,hj as bp,hk as Tp,hl as Sp,hm as wp,hn as Op,ho as vp,hp as _p,hq as Ap,hr as Ip,hs as Ep,ht as kp,hu as Cp,hv as Dp,hw as zp,hx as Lp,hy as $p,hz as Pp,hA as Vp,hB as Fp,hC as xp,hD as Rp,hE as jp,hF as Bp,hG as Hp,hH as Wp,hI as Up,hJ as qp,hK as Gp,hL as Kp,hM as Qp,hN as Jp,hO as Zp,hP as Xp,hQ as Yp,hR as Mp,hS as el,hT as tl,hU as al,hV as sl,hW as rl,hX as nl,hY as il,hZ as ol,h_ as ul,h$ as ml,i0 as pl,i1 as ll,i2 as cl,i3 as dl,i4 as hl,i5 as fl,i6 as yl,i7 as gl,i8 as Nl,i9 as bl,ia as Tl,ib as Sl,ic as wl,id as Ol,ie as vl,ig as _l,ih as Al,ii as Il,ij as El,ik as kl,il as Cl,im as Dl,io as zl,ip as Ll,iq as $l,ir as Pl,is as Vl,it as Fl,iu as xl,iv as Rl,iw as jl,ix as Bl,iy as Hl,iz as Wl,iA as Ul,iB as ql,iC as Gl,iD as Kl,iE as Ql,iF as Jl,iG as Zl,iH as Xl,iI as Yl,iJ as Ml,iK as ec,iL as tc,iM as ac,iN as sc,iO as rc,iP as nc,iQ as ic,iR as oc,iS as uc,iT as mc,iU as pc,iV as lc}from"./index-2MT1kXnv.js";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cc(a){return new dn(a)}function dc(a){return new hn(a)}function hc(){return new fn}function fc(a){return new yn(a)}const yc=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:cc,minMaxNorm:fc,nonNeg:hc,unitNorm:dc},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gc(){return new gn}function Nc(){return new Nn}function bc(a){return new bn(a)}function Tc(a){return new Tn(a)}function Sc(a){return new Sn(a)}function wc(a){return new wn(a)}function Oc(a){return new On(a)}function vc(a){return new vn(a)}function _c(a){return new _n(a)}function Ac(a){return new An(a)}function Ic(a){return new In(a)}function Ec(a){return new En(a)}function kc(a){return new kn(a)}function Cc(a){return new Cn(a)}function Dc(a){return new Dn(a)}const zc=Object.freeze(Object.defineProperty({__proto__:null,constant:bc,glorotNormal:Ac,glorotUniform:_c,heNormal:Ic,heUniform:Ec,identity:Oc,leCunNormal:kc,leCunUniform:Cc,ones:Nc,orthogonal:Dc,randomNormal:Sc,randomUniform:Tc,truncatedNormal:wc,varianceScaling:vc,zeros:gc},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lc(a){return new ge(a)}function $c(a){return new Je(a)}function Ur(a){return zn(a)}function Pc(a,e){Ln.registerCallbackConstructor(a,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vc(a){return new $n(a)}function Fc(a){return new Pn(a)}function xc(a){return new Vn(a)}function Rc(a){return new Fn(a)}function jc(a){return new xn(a)}function Bc(a){return new Rn(a)}function Hc(a){return new jn(a)}function Wc(a){return new Bn(a)}function Uc(a){return new Hn(a)}function qc(a){return new Wn(a)}function Gc(a){return new Un(a)}function Kc(a){return new qn(a)}function Qc(a){return new Gn(a)}function Jc(a){return new Kn(a)}function Zc(a){return new Qn(a)}function Xc(a){return new Jn(a)}function Yc(a){return new Zn(a)}function Mc(a){return new Xn(a)}function ed(a){return new Yn(a)}function td(a){return new Mn(a)}function ad(a){return new ei(a)}function sd(a){return new ti(a)}function rd(a){return new ai(a)}function nd(a){return new si(a)}function id(a){return new ri(a)}function od(a){return new ni(a)}function ud(a){return new ii(a)}function md(a){return new oi(a)}function pd(a){return new ui(a)}function ld(a){return new mi(a)}function cd(a){return new pi(a)}function dd(a){return new li(a)}function hd(a){return new ci(a)}function fd(a){return new di(a)}function yd(a){return new hi(a)}function Ee(a){return new fi(a)}function gd(a){return Ee(a)}function Nd(a){return Ee(a)}function ke(a){return new yi(a)}function bd(a){return ke(a)}function Td(a){return ke(a)}function Ce(a){return new gi(a)}function Sd(a){return Ce(a)}function wd(a){return Ce(a)}function Od(a){return new Ni(a)}function vd(a){return new bi(a)}function qr(a){return new Ti(a)}function Gr(a){return new Si(a)}function Kr(a){return new wi(a)}function Qr(a){return new Oi(a)}function _d(a){return new vi(a)}function Ad(a){return new _i(a)}function Id(a){return new Ai(a)}function Ed(a){return new Ii(a)}function kd(a){return new Ei(a)}function Cd(a){return new ki(a)}function Dd(a){return new Ci(a)}function zd(a){return new Di(a)}function Ld(a){return new zi(a)}function $d(a){return new Ne(a)}function Pd(a){return new Li(a)}function Vd(a){return new $i(a)}function Fd(a){return new Pi(a)}const xd=qr,Rd=Gr,jd=Kr,Bd=Qr;function Hd(a){return new Vi(a)}function Wd(a){return new Fi(a)}function Ud(a){return new xi(a)}function qd(a){return new Ri(a)}function Gd(a){return new ji(a)}function Kd(a){return new Bi(a)}function Qd(a){return new Hi(a)}function Jd(a){return new Wi(a)}function Zd(a){return new Ui(a)}const Xd=Object.freeze(Object.defineProperty({__proto__:null,Layer:qi,RNN:Ne,RNNCell:Gi,activation:Yc,add:od,alphaDropout:Ud,average:ud,averagePooling1d:Ee,averagePooling2d:ke,averagePooling3d:Ce,avgPool1d:gd,avgPool2d:bd,avgPool3d:Sd,avgPooling1d:Nd,avgPooling2d:Td,avgPooling3d:wd,batchNormalization:hd,bidirectional:Vd,categoryEncoding:Jd,centerCrop:Kd,concatenate:md,conv1d:Wc,conv2d:Uc,conv2dTranspose:qc,conv3d:Gc,conv3dTranspose:Kc,convLstm2d:zd,convLstm2dCell:Ld,cropping2D:Jc,dense:Mc,depthwiseConv2d:Xc,dot:dd,dropout:ed,elu:Fc,embedding:id,flatten:ad,gaussianDropout:Wd,gaussianNoise:Hd,globalAveragePooling1d:Od,globalAveragePooling2d:vd,globalMaxPool1d:xd,globalMaxPool2d:Rd,globalMaxPooling1d:qr,globalMaxPooling2d:Gr,gru:Ad,gruCell:Id,input:Ur,inputLayer:Vc,layerNormalization:fd,leakyReLU:Rc,lstm:Ed,lstmCell:kd,masking:qd,maxPool1d:jd,maxPool2d:Bd,maxPooling1d:Kr,maxPooling2d:Qr,maxPooling3d:_d,maximum:pd,minimum:ld,multiply:cd,permute:nd,prelu:jc,randomWidth:Zd,reLU:xc,repeatVector:sd,rescaling:Gd,reshape:rd,resizing:Qd,rnn:$d,separableConv2d:Qc,simpleRNN:Cd,simpleRNNCell:Dd,softmax:Bc,spatialDropout1d:td,stackedRNNCells:Pd,thresholdedReLU:Hc,timeDistributed:Fd,upSampling2d:Zc,zeroPadding2d:yd},Symbol.toStringTag,{value:"Module"}));function Yd(a,e){return Ki(a,e)}function Md(a,e){return Qi(a,e)}function eh(a,e){return Ji(a,e)}function th(a,e){return Zi(a,e)}function ah(a,e){return Xi(a,e)}function sh(a,e){return Yi(a,e)}function rh(a,e){return Mi(a,e)}function nh(a,e){return eo(a,e)}function ih(a,e){return to(a,e)}function oh(a,e){return be(a,e)}function uh(a,e){return be(a,e)}function mh(a,e){return be(a,e)}function ph(a,e){return Te(a,e)}function lh(a,e){return Te(a,e)}function ch(a,e){return Te(a,e)}function dh(a,e){return ao(a,e)}const hh=Object.freeze(Object.defineProperty({__proto__:null,MAPE:uh,MSE:lh,binaryAccuracy:Yd,binaryCrossentropy:Md,categoricalAccuracy:th,categoricalCrossentropy:ah,cosineProximity:nh,mape:mh,meanAbsoluteError:ih,meanAbsolutePercentageError:oh,meanSquaredError:ph,mse:ch,precision:sh,r2Score:dh,recall:rh,sparseCategoricalAccuracy:eh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fh=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:so},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yh(a){return new ro(a)}function gh(a){return no(a)}function Nh(a){return io(a)}const bh=Object.freeze(Object.defineProperty({__proto__:null,l1:gh,l1l2:yh,l2:Nh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Jr extends oo{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ge))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function q(a,e){return a<e}function xe(a,e){return a>e}class Zr extends Jr{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new uo("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=q:this.mode==="max"?this.monitorFunc=xe:this.monitor.indexOf("acc")!==-1?this.monitorFunc=xe:this.monitorFunc=q,this.monitorFunc===q&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===q?1/0:-1/0}async onEpochEnd(e,t){await mo(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function Th(a){return new Zr(a)}const Sh={earlyStopping:Th};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const De={};function wh(a,e){const t={tfOpName:a,category:"custom",inputs:[],attrs:[],customExecutor:e};De[a]=t}function Xr(a){return De[a]}function Oh(a){delete De[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,e,t,s,n){const i=e.inputParams[a];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,m=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,p=o<0?e.inputNames.length+o:o;if(i.type==="tensor")return T(e.inputNames[p],t,s,n);if(i.type==="tensors"){const c=e.inputs.slice(o,m);return e.inputNames.slice(o,m).filter((N,y)=>{var h;return((h=c[y])===null||h===void 0?void 0:h.op)!=="NoOp"}).map(N=>T(N,t,s,n))}const l=T(e.inputNames[p],t,s,n),d=l.dataSync();return i.type==="number"?d[0]:po(l.shape,d)}const u=e.attrParams[a];return u&&u.value}function T(a,e,t,s){const[n,i]=O(a,t);if(s!=null){const o=s.getHashTableHandleByName(n);if(o!=null)return o}const u=t.currentContextIds.find(o=>!!e[Y(n,o)]);return u!==void 0?e[Y(n,u)][i]:void 0}function Re(a,e,t){return e[Y(a,t.currentContextId)]}function z(a,e){const[t,s,n]=O(a,e);return[Y(t,e&&e.currentContextId),s,n]}function Y(a,e){return e?`${a}-${e}`:a}function O(a,e){if(a==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(a);if(i!=null)return i}const s=a.split(":");let n;if(s.length===1)n=[a,0,void 0];else{const i=s[0],u=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);n=[i,o,u]}return t&&e.parseNodeNameCache.set(a,n),n}function J(a,e,t){let s=r("pad",a,e,t);if(s==="explicit"){s=r("explicitPaddings",a,e,t);const n=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)n[i][0]=s[i*2],n[i][1]=s[i*2+1];return n}return s}function L(a){return a.kept?a:Se(a)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vh=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_h=Object.freeze(Object.defineProperty({__proto__:null,json:vh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ah=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ih=Object.freeze(Object.defineProperty({__proto__:null,json:Ah},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eh=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],kh=Object.freeze(Object.defineProperty({__proto__:null,json:Eh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ch=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Dh=Object.freeze(Object.defineProperty({__proto__:null,json:Ch},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zh=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Lh=Object.freeze(Object.defineProperty({__proto__:null,json:zh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $h=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ph=Object.freeze(Object.defineProperty({__proto__:null,json:$h},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vh=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Fh=Object.freeze(Object.defineProperty({__proto__:null,json:Vh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xh=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Rh=Object.freeze(Object.defineProperty({__proto__:null,json:xh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jh=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Bh=Object.freeze(Object.defineProperty({__proto__:null,json:jh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hh=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Wh=Object.freeze(Object.defineProperty({__proto__:null,json:Hh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uh=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],qh=Object.freeze(Object.defineProperty({__proto__:null,json:Uh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gh=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Kh=Object.freeze(Object.defineProperty({__proto__:null,json:Gh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qh=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Jh=Object.freeze(Object.defineProperty({__proto__:null,json:Qh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zh=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Xh=Object.freeze(Object.defineProperty({__proto__:null,json:Zh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yh=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Mh=Object.freeze(Object.defineProperty({__proto__:null,json:Yh},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ef=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],tf=Object.freeze(Object.defineProperty({__proto__:null,json:ef},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const af=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],sf=Object.freeze(Object.defineProperty({__proto__:null,json:af},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rf=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],nf=Object.freeze(Object.defineProperty({__proto__:null,json:rf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const of=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],uf=Object.freeze(Object.defineProperty({__proto__:null,json:of},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class je{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[_h,Ih,kh,Dh,Lh,Ph,Fh,Rh,Bh,Wh,qh,Kh,Jh,Xh,Mh,tf,sf,nf,uf],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,n)=>(s[n.tfOpName]=n,s),{})}transformGraph(e,t={}){const s=e.node,n=[],i=[],u=[],o=s.reduce((y,h)=>(y[h.name]=this.mapNode(h),h.op.startsWith("Placeholder")?n.push(y[h.name]):h.op==="Const"?i.push(y[h.name]):(h.input==null||h.input.length===0)&&u.push(y[h.name]),y),{});let m=[];const p=[];let l={},d={};t!=null&&(l=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const c=Object.keys(o);c.forEach(y=>{const h=o[y];h.inputNames.forEach((g,w)=>{const[D,,b]=z(g),x=o[D];if(x.outputs!=null){const W=x.outputs.indexOf(b);if(W!==-1){const U=`${D}:${W}`;h.inputNames[w]=U}}h.inputs.push(x),x.children.push(h)})}),Object.keys(d).length===0?c.forEach(y=>{const h=o[y];h.children.length===0&&p.push(h)}):Object.keys(d).forEach(y=>{const[h]=z(y),g=o[h];g!=null&&(g.signatureKey=d[y],p.push(g))}),Object.keys(l).length>0?Object.keys(l).forEach(y=>{const[h]=z(y),g=o[h];g&&(g.signatureKey=l[y],m.push(g))}):m=n;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((y,h)=>(y[h.signature.name]=this.mapFunction(h),y),{}));const N={nodes:o,inputs:m,outputs:p,weights:i,placeholders:n,signature:t,functions:f};return u.length>0&&(N.initNodes=u),N}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Xr(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(n=>n.startsWith("^")?n.slice(1):n),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((n,i)=>(n[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},n),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((n,i)=>{const u=i.type;let o;switch(i.type){case"string":o=ie(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=ie(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=de(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=de(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=ue(e.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=ue(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=ce(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=ce(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=oe(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=oe(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=fe(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=fe(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=le(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=le(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=he(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=he(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=me(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=me(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=pe(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=pe(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=Be(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=Be(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return n[i.name]={value:o,type:u},n},{})),s}mapFunction(e){const t=e.nodeDef,s=[],n=[];let i={};t!=null&&(i=t.reduce((d,c)=>(d[c.name]=this.mapNode(c),c.op==="Const"&&n.push(d[c.name]),d),{}));const u=[],o=[];e.signature.inputArg.forEach(d=>{const[c]=z(d.name),f={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ze(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,u.push(f),i[c]=f}),Object.keys(i).forEach(d=>{const c=i[d];c.inputNames.forEach((f,N)=>{const[y,,h]=z(f),g=i[y];if(g.outputs!=null){const w=g.outputs.indexOf(h);if(w!==-1){const D=`${y}:${w}`;c.inputNames[N]=D}}c.inputs.push(g),g.children.push(c)})});const p=e.ret;e.signature.outputArg.forEach(d=>{const[c,f]=z(p[d.name]),N=i[c];N!=null&&(N.defaultOutput=f,o.push(N))});const l=this.mapArgsToSignature(e);return{nodes:i,inputs:u,outputs:o,weights:n,placeholders:s,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function mf(a){const e=C().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Yr(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):mf(a);return e?t:t.toLowerCase()}function ie(a,e,t,s=!1){const n=a[e];return n!=null?Yr(n.s,s):t}function oe(a,e,t){const s=a[e];return s?s.b:t}function ue(a,e,t){const s=a[e]||{},n=s.i!=null?s.i:s.f!=null?s.f:t;return typeof n=="number"?n:parseInt(n,10)}function ze(a){switch(typeof a=="string"&&(a=v[a]),a){case v.DT_FLOAT:case v.DT_HALF:return"float32";case v.DT_INT32:case v.DT_INT64:case v.DT_INT8:case v.DT_UINT8:return"int32";case v.DT_BOOL:return"bool";case v.DT_DOUBLE:return"float32";case v.DT_STRING:return"string";case v.DT_COMPLEX64:case v.DT_COMPLEX128:return"complex64";default:return null}}function Be(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function me(a,e,t){const s=a[e];return s&&s.type?ze(s.type):t}function pe(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(n=>ze(n)):t}function Mr(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function le(a,e,t){const s=a[e];return s&&s.shape?Mr(s.shape):t}function ce(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(n=>typeof n=="number"?n:parseInt(n,10)):t}function de(a,e,t,s=!1){const n=a[e];return n&&n.list&&n.list.s?n.list.s.map(i=>Yr(i,s)):t}function he(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(n=>Mr(n)):t}function fe(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pf{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(n=>this.getInput(n)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((n,i)=>(n[i]=this.getAttr(i),n),{}))}getInput(e){return T(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return T(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return ue(this.node.rawAttrs,e,t);if(s.s!=null)return ie(this.node.rawAttrs,e,t);if(s.b!=null)return oe(this.node.rawAttrs,e,t);if(s.shape!=null)return le(this.node.rawAttrs,e,t);if(s.type!=null)return me(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return ce(this.node.rawAttrs,e,t);if(s.list.s!=null)return de(this.node.rawAttrs,e,t);if(s.list.shape!=null)return he(this.node.rawAttrs,e,t);if(s.list.b!=null)return fe(this.node.rawAttrs,e,t);if(s.list.type!=null)return pe(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Ze,abs:Xe,acos:Ye,acosh:Me,add:et,addN:tt,all:at,any:st,argMax:rt,argMin:nt,asin:it,asinh:ot,atan:ut,atan2:mt,atanh:pt,avgPool:lt,avgPool3d:ct,basicLSTMCell:dt,batchNorm:ht,batchNorm2d:ft,batchNorm3d:yt,batchNorm4d:gt,batchToSpaceND:Nt,bincount:bt,bitwiseAnd:Tt,booleanMaskAsync:St,broadcastArgs:wt,broadcastTo:Ot,buffer:vt,cast:we,ceil:_t,clipByValue:At,clone:Se,complex:It,concat:ee,concat1d:Et,concat2d:kt,concat3d:Ct,concat4d:Dt,conv1d:zt,conv2d:Lt,conv2dTranspose:$t,conv3d:Pt,conv3dTranspose:Vt,cos:Ft,cosh:xt,cosineWindow:Rt,cumprod:jt,cumsum:Bt,denseBincount:Ht,depthToSpace:Wt,depthwiseConv2d:Ut,diag:qt,dilation2d:Gt,div:Kt,divNoNan:Qt,dot:Jt,dropout:Zt,einsum:Xt,elu:Yt,enclosingPowerOfTwo:Mt,ensureShape:ea,equal:ta,erf:aa,euclideanNorm:sa,exp:ra,expandDims:Oe,expm1:na,eye:ia,fft:oa,fill:ua,floor:ma,floorDiv:pa,fused:la,gather:ca,gatherND:da,greater:ha,greaterEqual:fa,ifft:ya,imag:ga,image:ve,inTopKAsync:Na,irfft:ba,isFinite:Ta,isInf:Sa,isNaN:wa,leakyRelu:Oa,less:va,lessEqual:_a,linalg:Aa,linspace:Ia,localResponseNormalization:Ea,log:ka,log1p:Ca,logSigmoid:Da,logSoftmax:za,logSumExp:La,logicalAnd:$a,logicalNot:Pa,logicalOr:Va,logicalXor:Fa,losses:xa,lowerBound:Ra,matMul:ja,max:Ba,maxPool:Ha,maxPool3d:Wa,maxPoolWithArgmax:Ua,maximum:qa,mean:Ga,meshgrid:Ka,min:Qa,minimum:Ja,mirrorPad:Za,mod:Xa,moments:Ya,movingAverage:Ma,mul:es,multiRNNCell:ts,multinomial:as,neg:ss,norm:rs,notEqual:ns,oneHot:is,ones:os,onesLike:us,op:ms,outerProduct:ps,pad:ls,pad1d:cs,pad2d:ds,pad3d:hs,pad4d:fs,pool:ys,pow:gs,prelu:Ns,print:bs,prod:Ts,raggedGather:Ss,raggedRange:ws,raggedTensorToTensor:Os,rand:vs,randomGamma:_s,randomNormal:As,randomStandardNormal:Is,randomUniform:Es,randomUniformInt:ks,range:Cs,real:Ds,reciprocal:zs,relu:Ls,relu6:$s,reshape:A,reverse:Ps,reverse1d:Vs,reverse2d:Fs,reverse3d:xs,reverse4d:Rs,rfft:js,round:Bs,rsqrt:Hs,scalar:$,scatterND:Ws,searchSorted:Us,selu:qs,separableConv2d:Gs,setdiff1dAsync:Ks,sigmoid:Qs,sign:Js,signal:Zs,sin:Xs,sinh:Ys,slice:te,slice1d:Ms,slice2d:er,slice3d:tr,slice4d:ar,softmax:sr,softplus:rr,spaceToBatchND:nr,sparse:ir,sparseToDense:or,spectral:ur,split:mr,sqrt:pr,square:lr,squaredDifference:cr,squeeze:dr,stack:R,step:hr,stridedSlice:fr,string:yr,sub:gr,sum:Nr,tan:br,tanh:Tr,tensor:V,tensor1d:_e,tensor2d:Z,tensor3d:Sr,tensor4d:wr,tensor5d:Or,tensor6d:vr,tensorScatterUpdate:_r,tile:Ar,topk:Ir,transpose:Er,truncatedNormal:kr,unique:Cr,unsortedSegmentSum:Dr,unstack:j,upperBound:zr,variable:Lr,where:$r,whereAsync:Pr,zeros:Vr,zerosLike:Fr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lf=(a,e,t,s=S)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(r("a",a,e,t),r("b",a,e,t))];case"AddN":return[s.addN(r("tensors",a,e,t))];case"FloorMod":case"Mod":return[s.mod(r("a",a,e,t),r("b",a,e,t))];case"Mul":return[s.mul(r("a",a,e,t),r("b",a,e,t))];case"RealDiv":case"Div":return[s.div(r("a",a,e,t),r("b",a,e,t))];case"DivNoNan":return[s.divNoNan(r("a",a,e,t),r("b",a,e,t))];case"FloorDiv":return[s.floorDiv(r("a",a,e,t),r("b",a,e,t))];case"Sub":return[s.sub(r("a",a,e,t),r("b",a,e,t))];case"Minimum":return[s.minimum(r("a",a,e,t),r("b",a,e,t))];case"Maximum":return[s.maximum(r("a",a,e,t),r("b",a,e,t))];case"Pow":return[s.pow(r("a",a,e,t),r("b",a,e,t))];case"SquaredDifference":return[s.squaredDifference(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cf=(a,e,t,s=S)=>{switch(a.op){case"Abs":case"ComplexAbs":return[s.abs(r("x",a,e,t))];case"Acos":return[s.acos(r("x",a,e,t))];case"Acosh":return[s.acosh(r("x",a,e,t))];case"Asin":return[s.asin(r("x",a,e,t))];case"Asinh":return[s.asinh(r("x",a,e,t))];case"Atan":return[s.atan(r("x",a,e,t))];case"Atan2":return[s.atan2(r("x",a,e,t),r("y",a,e,t))];case"Atanh":return[s.atanh(r("x",a,e,t))];case"Ceil":return[s.ceil(r("x",a,e,t))];case"Complex":return[s.complex(r("real",a,e,t),r("imag",a,e,t))];case"Cos":return[s.cos(r("x",a,e,t))];case"Cosh":return[s.cosh(r("x",a,e,t))];case"Elu":return[s.elu(r("x",a,e,t))];case"Erf":return[s.erf(r("x",a,e,t))];case"Exp":return[s.exp(r("x",a,e,t))];case"Expm1":return[s.expm1(r("x",a,e,t))];case"Floor":return[s.floor(r("x",a,e,t))];case"Log":return[s.log(r("x",a,e,t))];case"Log1p":return[s.log1p(r("x",a,e,t))];case"Imag":return[s.imag(r("x",a,e,t))];case"Neg":return[s.neg(r("x",a,e,t))];case"Reciprocal":return[s.reciprocal(r("x",a,e,t))];case"Real":return[s.real(r("x",a,e,t))];case"Relu":return[s.relu(r("x",a,e,t))];case"Round":return[s.round(r("x",a,e,t))];case"Selu":return[s.selu(r("x",a,e,t))];case"Sigmoid":return[s.sigmoid(r("x",a,e,t))];case"Sin":return[s.sin(r("x",a,e,t))];case"Sign":return[s.sign(r("x",a,e,t))];case"Sinh":return[s.sinh(r("x",a,e,t))];case"Softplus":return[s.softplus(r("x",a,e,t))];case"Sqrt":return[s.sqrt(r("x",a,e,t))];case"Square":return[s.square(r("x",a,e,t))];case"Tanh":return[s.tanh(r("x",a,e,t))];case"Tan":return[s.tan(r("x",a,e,t))];case"ClipByValue":return[s.clipByValue(r("x",a,e,t),r("clipValueMin",a,e,t),r("clipValueMax",a,e,t))];case"Relu6":return[s.relu6(r("x",a,e,t))];case"Rsqrt":return[s.rsqrt(T(a.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(r("x",a,e,t),r("alpha",a,e,t))];case"Prelu":return[s.prelu(r("x",a,e,t),r("alpha",a,e,t))];case"IsNan":return[s.isNaN(T(a.inputNames[0],e,t))];case"IsInf":return[s.isInf(T(a.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(T(a.inputNames[0],e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){k(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const n=a[s],i=e[s];k(n<0||i<0||n===i,()=>t+` Shapes ${a} and ${e} must match`)}}}function He(a){return!(typeof a=="number"||a.some(e=>e<0))}function B(a,e,t){let s=ye(a,t);const n=!He(s);if(n&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(n&&e.forEach(i=>{s=ye(i.shape,s)}),!He(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function ye(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const n=a[s],i=e[s];if(n>=0&&i>=0&&n!==i)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=n>=0?n:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class df{constructor(e,t,s,n,i,u,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=n,this.identicalElementShapes=i,this.dynamicSize=u,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=$(0),E(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),_(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,E(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,n)=>this.write(s,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let n=0;n<this.size();n++)e.push(n)}if(e.length===0)return V([],[0].concat(this.elementShape));const s=this.readMany(e);return _(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),R(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return V([],[0].concat(this.elementShape));const t=[];for(let n=0;n<this.size();n++)t.push(n);const s=this.readMany(t);return _(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ee(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,j(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const n=e.map(m=>(s+=m,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,u=[];I(()=>{t=A(t,[1,s,i]);for(let m=0;m<e.length;++m){const l=[0,m===0?0:n[m-1],0],d=[1,e[m],i];u[m]=A(te(t,l,d),this.elementShape)}return u});const o=[];for(let m=0;m<e.length;m++)o[m]=m;this.writeMany(o,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F{get id(){return this.idTensor.id}constructor(e,t,s,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);_(t,i.shape,"TensorList shape mismatch: "),E(i)}),this.idTensor=$(0),this.maxNumElements=n,E(this.idTensor)}copy(){return new F([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);_(e,this.elementShape,"TensorList shape mismatch: ");const n=B(this.elementShape,this.tensors,e);return I(()=>{const i=this.tensors.map(u=>A(u,n));return R(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=B(this.elementShape,this.tensors,e),n=this.tensors.pop();return n.kept=!1,_(n.shape,e,"TensorList shape mismatch: "),A(n,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(_(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");E(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new F([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);_(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=B(this.elementShape,this.tensors,t);return A(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);_(this.elementShape,t.shape,"TensorList shape mismatch: "),E(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);_(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=B(this.elementShape,this.tensors,s);return e.length===0?V([],[0].concat(n)):I(()=>{const i=e.map(u=>A(this.tensors[u],n));return R(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);_(this.elementShape,t,"TensorList shape mismatch: ");const s=B(this.elementShape,this.tensors,t);return this.size()===0?V([],[0].concat(s)):I(()=>{const n=this.tensors.map(i=>A(i,s));return ee(n,0)})}}function hf(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const n=a.shape.slice(1);_(n,e,"TensorList shape mismatch: ");const i=j(a);return new F(i,e,s)}function ff(a,e,t,s){return new F([],a,e,s)}function yf(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const n=Math.max(...e);if(s!=null&&s!==-1&&n>=s)throw new Error(`Max index must be < array size (${n}  vs. ${s})`);const i=new F([],t,a.dtype,s),u=j(a,0);return e.forEach((o,m)=>{i.setItem(o,u[m])}),i}function gf(a,e,t){let s=0;const n=e.map(l=>(s+=l,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const i=a.shape.slice(1),u=ye(i,t),o=s===0?0:a.size/s,m=I(()=>{const l=[];a=A(a,[1,s,o]);for(let d=0;d<e.length;++d){const f=[0,d===0?0:n[d-1],0],N=[1,e[d],o];l[d]=A(te(a,f,N),u)}return a.dispose(),l}),p=new F([],t,a.dtype,e.length);for(let l=0;l<m.length;l++)p.setItem(l,m[l]);return p}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nf=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=r("thenBranch",a,e,t),n=r("elseBranch",a,e,t),i=r("cond",a,e,t),u=r("args",a,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap):t.functionMap[n].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=r("body",a,e,t),n=r("cond",a,e,t),i=r("args",a,e,t),u=await t.functionMap[n].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(l=>l.id);let m=await u[0].data();u.forEach(l=>{!l.kept&&o.indexOf(l.id)===-1&&l.dispose()});let p=i;for(;m[0];){const l=p;p=await t.functionMap[s].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);const d=p.map(f=>f.id);l.forEach(f=>{!f.kept&&o.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()});const c=await t.functionMap[n].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);m=await c[0].data(),c.forEach(f=>{!f.kept&&o.indexOf(f.id)===-1&&d.indexOf(f.id)===-1&&f.dispose()})}return p}case"LoopCond":{const s=r("pred",a,e,t);return[L(s)]}case"Switch":{const s=r("pred",a,e,t);let n=r("data",a,e,t);return n.kept||(n=L(n)),(await s.data())[0]?[void 0,n]:[n,void 0]}case"Merge":{const s=a.inputNames.find(n=>T(n,e,t)!==void 0);if(s){const n=T(s,e,t);return[L(n)]}return}case"Enter":{const s=r("frameName",a,e,t),n=r("tensor",a,e,t);return t.enterFrame(s),[L(n)]}case"Exit":{const s=r("tensor",a,e,t);return t.exitFrame(),[L(s)]}case"NextIteration":{const s=r("tensor",a,e,t);return t.nextIteration(),[L(s)]}case"TensorArrayV3":{const s=r("size",a,e,t),n=r("dtype",a,e,t),i=r("elementShape",a,e,t),u=r("dynamicSize",a,e,t),o=r("clearAfterRead",a,e,t),m=r("identicalElementShapes",a,e,t),p=r("name",a,e,t),l=new df(p,n,s,i,m,u,o);return t.addTensorArray(l),[l.idTensor,$(1)]}case"TensorArrayWriteV3":{const s=r("tensorArrayId",a,e,t),n=r("index",a,e,t),i=r("tensor",a,e,t),u=t.getTensorArray(s.id);return u.write(n,i),[u.idTensor]}case"TensorArrayReadV3":{const s=r("tensorArrayId",a,e,t),n=r("index",a,e,t);return[t.getTensorArray(s.id).read(n)]}case"TensorArrayGatherV3":{const s=r("tensorArrayId",a,e,t),n=r("indices",a,e,t),i=r("dtype",a,e,t);return[t.getTensorArray(s.id).gather(n,i)]}case"TensorArrayScatterV3":{const s=r("tensorArrayId",a,e,t),n=r("indices",a,e,t),i=r("tensor",a,e,t),u=t.getTensorArray(s.id);return u.scatter(n,i),[u.idTensor]}case"TensorArrayConcatV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id),i=r("dtype",a,e,t);return[n.concat(i)]}case"TensorArraySplitV3":{const s=r("tensorArrayId",a,e,t),n=r("tensor",a,e,t),i=r("lengths",a,e,t),u=t.getTensorArray(s.id);return u.split(i,n),[u.idTensor]}case"TensorArraySizeV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id);return[$(n.size(),"int32")]}case"TensorArrayCloseV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id);return n.clearAndClose(),[n.idTensor]}case"TensorListSetItem":{const s=r("tensorListId",a,e,t),n=r("index",a,e,t),i=r("tensor",a,e,t),u=t.getTensorList(s.id);return u.setItem(n,i),[u.idTensor]}case"TensorListGetItem":{const s=r("tensorListId",a,e,t),n=r("index",a,e,t),i=r("elementShape",a,e,t),u=r("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(n,i,u)]}case"TensorListScatterV2":case"TensorListScatter":{const s=r("indices",a,e,t),n=r("tensor",a,e,t),i=r("elementShape",a,e,t),u=r("numElements",a,e,t),o=yf(n,s,i,u);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=r("elementShape",a,e,t),n=r("elementDType",a,e,t);let i;a.op==="TensorListReserve"?i="numElements":i="maxNumElements";const u=r(i,a,e,t),o=a.op==="TensorListReserve"?-1:u,m=ff(s,n,u,o);return t.addTensorList(m),[m.idTensor]}case"TensorListGather":{const s=r("tensorListId",a,e,t),n=r("indices",a,e,t),i=r("elementShape",a,e,t),u=r("elementDType",a,e,t);return[t.getTensorList(s.id).gather(n,u,i)]}case"TensorListStack":{const s=r("tensorListId",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t),u=r("numElements",a,e,t);return[t.getTensorList(s.id).stack(n,i,u)]}case"TensorListFromTensor":{const s=r("tensor",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t),u=hf(s,n,i);return t.addTensorList(u),[u.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=r("tensorListId",a,e,t),n=t.getTensorList(s.id),i=r("dtype",a,e,t),u=r("elementShape",a,e,t);return[n.concat(i,u)]}case"TensorListPushBack":{const s=r("tensorListId",a,e,t),n=r("tensor",a,e,t),i=t.getTensorList(s.id);return i.pushBack(n),[i.idTensor]}case"TensorListPopBack":{const s=r("tensorListId",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(n,i)]}case"TensorListSplit":{const s=r("tensor",a,e,t),n=r("elementShape",a,e,t),i=r("lengths",a,e,t),u=gf(s,i,n);return t.addTensorList(u),[u.idTensor]}case"TensorListLength":{const s=r("tensorListId",a,e,t),n=t.getTensorList(s.id);return[$(n.size(),"int32")]}case"TensorListResize":{const s=r("tensorListId",a,e,t),n=r("size",a,e,t),u=t.getTensorList(s.id).resize(n);return t.addTensorList(u),[u.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(a,e,t){const[s,n]=r("fusedOps",a,e,t),i=s==="biasadd",u=!i,o=n==="prelu",m=s==="fusedbatchnorm",p=r("numArgs",a,e,t);if(i){if(o&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(m)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=r("strides",a,e,t),d=J(a,e,t),c=r("dataFormat",a,e,t).toUpperCase(),f=r("dilations",a,e,t);let[N,y]=r("args",a,e,t);u&&(y=N,N=void 0);const h=r("leakyreluAlpha",a,e,t);return{stride:l,pad:d,dataFormat:c,dilations:f,biasArg:N,preluArg:y,activationFunc:n,leakyreluAlpha:h}}const bf=(a,e,t,s=S)=>{switch(a.op){case"Conv1D":{const n=r("stride",a,e,t),i=r("pad",a,e,t),u=r("dataFormat",a,e,t).toUpperCase(),o=r("dilation",a,e,t);return[s.conv1d(r("x",a,e,t),r("filter",a,e,t),n,i,u,o)]}case"Conv2D":{const n=r("strides",a,e,t),i=J(a,e,t),u=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[s.conv2d(r("x",a,e,t),r("filter",a,e,t),[n[1],n[2]],i,u,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:n,pad:i,dataFormat:u,dilations:o,biasArg:m,preluArg:p,activationFunc:l,leakyreluAlpha:d}=We(a,e,t);return[s.fused.conv2d({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[n[1],n[2]],pad:i,dataFormat:u,dilations:[o[1],o[2]],bias:m,activation:l,preluActivationWeights:p,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:i,dataFormat:u,dilations:o,biasArg:m,preluArg:p,activationFunc:l,leakyreluAlpha:d}=We(a,e,t);return[s.fused.depthwiseConv2d({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[n[1],n[2]],pad:i,dataFormat:u,dilations:[o[1],o[2]],bias:m,activation:l,preluActivationWeights:p,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=r("outputShape",a,e,t),i=r("strides",a,e,t),u=J(a,e,t);return[s.conv2dTranspose(r("x",a,e,t),r("filter",a,e,t),n,[i[1],i[2]],u)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=r("strides",a,e,t),i=J(a,e,t),u=r("dilations",a,e,t),o=r("dataFormat",a,e,t).toUpperCase();return[s.depthwiseConv2d(r("input",a,e,t),r("filter",a,e,t),[n[1],n[2]],i,o,[u[1],u[2]])]}case"Conv3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[s.conv3d(r("x",a,e,t),r("filter",a,e,t),[n[1],n[2],n[3]],i,u,[o[1],o[2],o[3]])]}case"AvgPool":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("kernelSize",a,e,t);return[s.avgPool(r("x",a,e,t),[u[1],u[2]],[n[1],n[2]],i)]}case"MaxPool":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("kernelSize",a,e,t);return[s.maxPool(r("x",a,e,t),[u[1],u[2]],[n[1],n[2]],i)]}case"MaxPoolWithArgmax":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("kernelSize",a,e,t),o=r("includeBatchInIndex",a,e,t),{result:m,indexes:p}=s.maxPoolWithArgmax(r("x",a,e,t),[u[1],u[2]],[n[1],n[2]],i,o);return[m,p]}case"AvgPool3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("kernelSize",a,e,t);return[s.avgPool3d(r("x",a,e,t),[u[1],u[2],u[3]],[n[1],n[2],n[3]],i)]}case"MaxPool3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("kernelSize",a,e,t);return[s.maxPool3d(r("x",a,e,t),[u[1],u[2],u[3]],[n[1],n[2],n[3]],i)]}case"Dilation2D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),u=r("dilations",a,e,t),o=n[1],m=n[2],p=u[1],l=u[2];return[s.dilation2d(r("x",a,e,t),r("filter",a,e,t),[o,m],i,[p,l],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tf=(a,e,t,s=S)=>{switch(a.op){case"Fill":{const n=r("shape",a,e,t),i=r("dtype",a,e,t),u=r("value",a,e,t);return[s.fill(n,u,i)]}case"LinSpace":{const n=r("start",a,e,t),i=r("stop",a,e,t),u=r("num",a,e,t);return[s.linspace(n,i,u)]}case"Multinomial":{const n=r("logits",a,e,t),i=r("numSamples",a,e,t),u=r("seed",a,e,t);return[s.multinomial(n,i,u)]}case"OneHot":{const n=r("indices",a,e,t),i=r("depth",a,e,t),u=r("onValue",a,e,t),o=r("offValue",a,e,t),m=r("dtype",a,e,t);return[s.oneHot(n,i,u,o,m)]}case"Ones":return[s.ones(r("shape",a,e,t),r("dtype",a,e,t))];case"OnesLike":return[s.onesLike(r("x",a,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(r("shape",a,e,t),r("dtype",a,e,t),r("seed",a,e,t))];case"RandomUniform":return[s.randomUniform(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("dtype",a,e,t))];case"RandomUniformInt":return[s.randomUniformInt(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("seed",a,e,t))];case"Range":{const n=r("start",a,e,t),i=r("stop",a,e,t),u=r("step",a,e,t);return[s.range(n,i,u,r("dtype",a,e,t))]}case"TruncatedNormal":{const n=r("shape",a,e,t),i=r("mean",a,e,t),u=r("stdDev",a,e,t),o=r("seed",a,e,t);return[s.truncatedNormal(n,i,u,r("dtype",a,e,t),o)]}case"Zeros":return[s.zeros(r("shape",a,e,t),r("dtype",a,e,t))];case"ZerosLike":return[s.zerosLike(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function se(a,e,t){const s=r("boxes",a,e,t),n=r("scores",a,e,t),i=r("maxOutputSize",a,e,t),u=r("iouThreshold",a,e,t),o=r("scoreThreshold",a,e,t),m=r("softNmsSigma",a,e,t);return{boxes:s,scores:n,maxOutputSize:i,iouThreshold:u,scoreThreshold:o,softNmsSigma:m}}const Sf=async(a,e,t,s,n=S)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:u,maxOutputSize:o,iouThreshold:m,scoreThreshold:p,softNmsSigma:l}=se(a,e,t),d=await n.image.nonMaxSuppressionWithScoreAsync(i,u,o,m,p,l);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:u,maxOutputSize:o,iouThreshold:m,scoreThreshold:p}=se(a,e,t),l=r("padToMaxOutputSize",a,e,t),d=await n.image.nonMaxSuppressionPaddedAsync(i,u,o,m,p,l);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:u,maxOutputSize:o,iouThreshold:m,scoreThreshold:p}=se(a,e,t);return[await n.image.nonMaxSuppressionAsync(i,u,o,m,p)]}case"Where":{const i=n.cast(r("condition",a,e,t),"bool"),u=[await n.whereAsync(i)];return i.dispose(),u}case"ListDiff":return n.setdiff1dAsync(r("x",a,e,t),r("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wf=(a,e,t,s=S)=>{switch(a.op){case"LowerBound":{const n=r("sortedSequence",a,e,t),i=r("values",a,e,t);return[s.lowerBound(n,i)]}case"TopKV2":{const n=r("x",a,e,t),i=r("k",a,e,t),u=r("sorted",a,e,t),o=s.topk(n,i,u);return[o.values,o.indices]}case"UpperBound":{const n=r("sortedSequence",a,e,t),i=r("values",a,e,t);return[s.upperBound(n,i)]}case"Unique":{const n=r("x",a,e,t),i=s.unique(n);return[i.values,i.indices]}case"UniqueV2":{const n=r("x",a,e,t),i=r("axis",a,e,t),u=s.unique(n,i);return[u.values,u.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Of=(a,e,t,s=S)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const n=r("default",a,e,t);return[T(a.name,e,t)||n];case"Placeholder":return[T(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=r("x",a,e,t);return[L(l)]}case"IdentityN":return r("x",a,e,t).map(l=>L(l));case"Snapshot":const i=r("x",a,e,t);return[L(i)];case"Shape":return[s.tensor1d(r("x",a,e,t).shape,"int32")];case"ShapeN":return r("x",a,e,t).map(l=>s.tensor1d(l.shape));case"Size":return[s.scalar(r("x",a,e,t).size,"int32")];case"Rank":return[s.scalar(r("x",a,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const u=r("x",a,e,t),o=r("data",a,e,t),m=r("message",a,e,t),p=r("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(m);for(let l=0;l<o.length;l++)console.log(Array.prototype.slice.call(o[l].dataSync()).slice(0,p));return[u];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vf{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=$(0),this.tensorMap=new Map,E(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return $(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),I(()=>{const n=j(t),i=s.length,u=n.length;k(i===u,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${u} elements.`);for(let o=0;o<i;o++){const m=s[o],p=n[o];E(p),this.tensorMap.set(m,p)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return I(()=>{const n=[];for(let i=0;i<s.length;i++){const u=s[i],o=this.findWithDefault(u,t);n.push(o)}return R(n)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _f=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const n=s.getHashTableHandleByName(a.name);if(n!=null)return[n];{const i=r("keyDType",a,e,t),u=r("valueDType",a,e,t),o=new vf(i,u);return s.addHashTable(a.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const n=r("tableHandle",a,e,t,s),i=r("keys",a,e,t),u=r("values",a,e,t);return[await s.getHashTableById(n.id).import(i,u)]}case"LookupTableFind":case"LookupTableFindV2":{const n=r("tableHandle",a,e,t,s),i=r("keys",a,e,t),u=r("defaultValue",a,e,t);return[await s.getHashTableById(n.id).find(i,u)]}case"LookupTableSize":case"LookupTableSizeV2":{const n=r("tableHandle",a,e,t,s);return[s.getHashTableById(n.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Af=(a,e,t,s=S)=>{switch(a.op){case"ResizeBilinear":{const n=r("images",a,e,t),i=r("size",a,e,t),u=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[s.image.resizeBilinear(n,[i[0],i[1]],u,o)]}case"ResizeNearestNeighbor":{const n=r("images",a,e,t),i=r("size",a,e,t),u=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[s.image.resizeNearestNeighbor(n,[i[0],i[1]],u,o)]}case"CropAndResize":{const n=r("image",a,e,t),i=r("boxes",a,e,t),u=r("boxInd",a,e,t),o=r("cropSize",a,e,t),m=r("method",a,e,t),p=r("extrapolationValue",a,e,t);return[s.image.cropAndResize(n,i,u,o,m,p)]}case"ImageProjectiveTransformV3":{const n=r("images",a,e,t),i=r("transforms",a,e,t),u=r("outputShape",a,e,t),o=r("fillValue",a,e,t),m=r("interpolation",a,e,t),p=r("fillMode",a,e,t);return[s.image.transform(n,i,m.toLowerCase(),p.toLowerCase(),o,u)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const If=(a,e,t,s=S)=>{switch(a.op){case"Equal":return[s.equal(r("a",a,e,t),r("b",a,e,t))];case"NotEqual":return[s.notEqual(r("a",a,e,t),r("b",a,e,t))];case"Greater":return[s.greater(r("a",a,e,t),r("b",a,e,t))];case"GreaterEqual":return[s.greaterEqual(r("a",a,e,t),r("b",a,e,t))];case"Less":return[s.less(r("a",a,e,t),r("b",a,e,t))];case"LessEqual":return[s.lessEqual(r("a",a,e,t),r("b",a,e,t))];case"LogicalAnd":return[s.logicalAnd(r("a",a,e,t),r("b",a,e,t))];case"LogicalNot":return[s.logicalNot(r("a",a,e,t))];case"LogicalOr":return[s.logicalOr(r("a",a,e,t),r("b",a,e,t))];case"Select":case"SelectV2":return[s.where(r("condition",a,e,t),r("a",a,e,t),r("b",a,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ef=(a,e,t,s=S)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(r("a",a,e,t),r("b",a,e,t),r("transposeA",a,e,t),r("transposeB",a,e,t))];case"Einsum":return[s.einsum(r("equation",a,e,t),...r("tensors",a,e,t))];case"Transpose":return[s.transpose(r("x",a,e,t),r("perm",a,e,t))];case"_FusedMatMul":const[n,i]=r("fusedOps",a,e,t),u=n==="biasadd",o=i==="prelu",m=r("numArgs",a,e,t),p=r("leakyreluAlpha",a,e,t);if(u){if(o&&m!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&m!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,d]=r("args",a,e,t);return[s.fused.matMul({a:r("a",a,e,t),b:r("b",a,e,t),transposeA:r("transposeA",a,e,t),transposeB:r("transposeB",a,e,t),bias:l,activation:i,preluActivationWeights:d,leakyreluAlpha:p})];case"MatrixBandPart":return[s.linalg.bandPart(r("a",a,e,t),r("numLower",a,e,t),r("numUpper",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kf=(a,e,t,s=S)=>{switch(a.op){case"EuclideanNorm":return[s.euclideanNorm(r("x",a,e,t),r("axis",a,e,t),r("keepDims",a,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"FusedBatchNormV3":return[s.batchNorm(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"LRN":return[s.localResponseNormalization(r("x",a,e,t),r("radius",a,e,t),r("bias",a,e,t),r("alpha",a,e,t),r("beta",a,e,t))];case"Softmax":return[s.softmax(r("x",a,e,t))];case"LogSoftmax":return[s.logSoftmax(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cf=(a,e,t,s=S)=>{switch(a.op){case"RaggedGather":{const{outputNestedSplits:n,outputDenseValues:i}=s.raggedGather(r("paramsNestedSplits",a,e,t),r("paramsDenseValues",a,e,t),r("indices",a,e,t),r("outputRaggedRank",a,e,t));return n.concat(i)}case"RaggedRange":{const{rtNestedSplits:n,rtDenseValues:i}=s.raggedRange(r("starts",a,e,t),r("limits",a,e,t),r("splits",a,e,t));return[n,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(r("shape",a,e,t),r("values",a,e,t),r("defaultValue",a,e,t),r("rowPartitionTensors",a,e,t),r("rowPartitionTypes",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Df=(a,e,t,s=S)=>{switch(a.op){case"Max":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.max(r("x",a,e,t),o,m)]}case"Mean":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.mean(r("x",a,e,t),o,m)]}case"Min":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.min(r("x",a,e,t),o,m)]}case"Sum":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.sum(r("x",a,e,t),o,m)]}case"All":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.all(r("x",a,e,t),o,m)]}case"Any":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.any(r("x",a,e,t),o,m)]}case"ArgMax":{const o=r("axis",a,e,t);return[s.argMax(r("x",a,e,t),o)]}case"ArgMin":{const o=r("axis",a,e,t);return[s.argMin(r("x",a,e,t),o)]}case"Prod":{const o=r("axis",a,e,t),m=r("keepDims",a,e,t);return[s.prod(r("x",a,e,t),o,m)]}case"Cumprod":{const o=r("axis",a,e,t),m=r("exclusive",a,e,t),p=r("reverse",a,e,t);return[s.cumprod(r("x",a,e,t),o,m,p)]}case"Cumsum":{const o=r("axis",a,e,t),m=r("exclusive",a,e,t),p=r("reverse",a,e,t);return[s.cumsum(r("x",a,e,t),o,m,p)]}case"Bincount":const n=r("x",a,e,t),i=r("weights",a,e,t),u=r("size",a,e,t);return[s.bincount(n,i,u)];case"DenseBincount":{const o=r("x",a,e,t),m=r("weights",a,e,t),p=r("size",a,e,t),l=r("binaryOutput",a,e,t);return[s.denseBincount(o,m,p,l)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zf=(a,e,t,s=S)=>{switch(a.op){case"ConcatV2":case"Concat":{const n=r("n",a,e,t),i=r("axis",a,e,t);let u=r("tensors",a,e,t);return u=u.slice(0,n),[s.concat(u,i)]}case"Gather":{const n=r("x",a,e,t),i=r("indices",a,e,t);return[s.gather(n,s.cast(i,"int32"),0)]}case"GatherV2":{const n=r("axis",a,e,t),i=r("batchDims",a,e,t),u=r("x",a,e,t),o=r("indices",a,e,t);return[s.gather(u,s.cast(o,"int32"),n,i)]}case"Reverse":{const n=r("dims",a,e,t),i=[];for(let o=0;o<n.length;o++)n[o]&&i.push(o);const u=r("x",a,e,t);return[s.reverse(u,i)]}case"ReverseV2":{const n=r("axis",a,e,t),i=r("x",a,e,t);return[s.reverse(i,n)]}case"Slice":{const n=r("begin",a,e,t),i=r("size",a,e,t);return[s.slice(r("x",a,e,t),n,i)]}case"StridedSlice":{const n=r("begin",a,e,t),i=r("end",a,e,t),u=r("strides",a,e,t),o=r("beginMask",a,e,t),m=r("endMask",a,e,t),p=r("ellipsisMask",a,e,t),l=r("newAxisMask",a,e,t),d=r("shrinkAxisMask",a,e,t),c=r("x",a,e,t);return[s.stridedSlice(c,n,i,u,o,m,p,l,d)]}case"Pack":return I(()=>{const n=r("axis",a,e,t),i=r("tensors",a,e,t),u=i[0].shape,o=s.squeeze(i[0]).shape,m=i.map(p=>{const l=Ve(p.shape,u);if(!l&&!Ve(s.squeeze(p).shape,o))throw new Error("the input tensors shape does not match");return l?p:s.reshape(p,u)});return[s.stack(m,n)]});case"Unpack":{const n=r("axis",a,e,t),i=r("tensor",a,e,t);return s.unstack(i,n)}case"Tile":{const n=r("reps",a,e,t);return[s.tile(r("x",a,e,t),n)]}case"Split":case"SplitV":{const n=r("axis",a,e,t),i=r("numOrSizeSplits",a,e,t),u=r("x",a,e,t);return s.split(u,i,n)}case"ScatterNd":{const n=r("indices",a,e,t),i=r("values",a,e,t),u=r("shape",a,e,t);return[s.scatterND(n,i,u)]}case"GatherNd":{const n=r("x",a,e,t),i=r("indices",a,e,t);return[s.gatherND(n,i)]}case"SparseToDense":{const n=r("sparseIndices",a,e,t),i=r("outputShape",a,e,t),u=r("sparseValues",a,e,t),o=r("defaultValue",a,e,t);return[s.sparseToDense(n,u,i,u.dtype===o.dtype?o:s.cast(o,u.dtype))]}case"TensorScatterUpdate":{const n=r("indices",a,e,t),i=r("values",a,e,t),u=r("tensor",a,e,t);return[s.tensorScatterUpdate(u,n,i)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lf=(a,e,t,s=S)=>{switch(a.op){case"SparseFillEmptyRows":{const{outputIndices:n,outputValues:i,emptyRowIndicator:u,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(r("indices",a,e,t),r("values",a,e,t),r("denseShape",a,e,t),r("defaultValue",a,e,t));return[n,i,u,o]}case"SparseReshape":{const{outputIndices:n,outputShape:i}=s.sparse.sparseReshape(r("inputIndices",a,e,t),r("inputShape",a,e,t),r("newShape",a,e,t));return[n,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(r("data",a,e,t),r("indices",a,e,t),r("segmentIds",a,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(r("data",a,e,t),r("indices",a,e,t),r("segmentIds",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $f=(a,e,t,s=S)=>{switch(a.op){case"FFT":return[s.fft(r("x",a,e,t))];case"IFFT":return[s.ifft(r("x",a,e,t))];case"RFFT":return[s.rfft(r("x",a,e,t))];case"IRFFT":return[s.irfft(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pf=(a,e,t,s=S)=>{switch(a.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(r("input",a,e,t),r("pattern",a,e,t),r("rewrite",a,e,t),r("replaceGlobal",a,e,t))];case"StringNGrams":{const{nGrams:n,nGramsSplits:i}=s.string.stringNGrams(r("data",a,e,t),r("dataSplits",a,e,t),r("separator",a,e,t),r("nGramWidths",a,e,t),r("leftPad",a,e,t),r("rightPad",a,e,t),r("padWidth",a,e,t),r("preserveShortSequences",a,e,t));return[n,i]}case"StringSplit":{const{indices:n,values:i,shape:u}=s.string.stringSplit(r("input",a,e,t),r("delimiter",a,e,t),r("skipEmpty",a,e,t));return[n,i,u]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(r("input",a,e,t),r("numBuckets",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vf=(a,e,t,s=S)=>{switch(a.op){case"Cast":return[s.cast(r("x",a,e,t),r("dtype",a,e,t))];case"ExpandDims":{const n=r("axis",a,e,t);return[s.expandDims(r("x",a,e,t),n)]}case"Squeeze":{const n=r("axis",a,e,t);return[s.squeeze(r("x",a,e,t),n)]}case"Reshape":return[s.reshape(r("x",a,e,t),r("shape",a,e,t))];case"EnsureShape":return[s.ensureShape(r("x",a,e,t),r("shape",a,e,t))];case"MirrorPad":return[s.mirrorPad(r("x",a,e,t),r("padding",a,e,t),r("mode",a,e,t))];case"PadV2":case"Pad":return[s.pad(r("x",a,e,t),r("padding",a,e,t),r("constantValue",a,e,t))];case"SpaceToBatchND":{const n=r("blockShape",a,e,t),i=r("paddings",a,e,t);return[s.spaceToBatchND(r("x",a,e,t),n,i)]}case"BatchToSpaceND":{const n=r("blockShape",a,e,t),i=r("crops",a,e,t);return[s.batchToSpaceND(r("x",a,e,t),n,i)]}case"DepthToSpace":{const n=r("blockSize",a,e,t),i=r("dataFormat",a,e,t).toUpperCase();return[s.depthToSpace(r("x",a,e,t),n,i)]}case"BroadcastTo":return[s.broadcastTo(r("x",a,e,t),r("shape",a,e,t))];case"BroadcastArgs":return[s.broadcastArgs(r("s0",a,e,t),r("s1",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ue(a,e,t,s,n=I){const i=((u,o,m)=>{switch(u.category){case"arithmetic":return n(()=>lf(u,o,m));case"basic_math":return n(()=>cf(u,o,m));case"control":return Nf(u,o,m);case"convolution":return n(()=>bf(u,o,m));case"creation":return n(()=>Tf(u,o,m));case"dynamic":return Sf(u,o,m);case"evaluation":return n(()=>wf(u,o,m));case"image":return n(()=>Af(u,o,m));case"graph":return n(()=>Of(u,o,m));case"logical":return n(()=>If(u,o,m));case"matrices":return n(()=>Ef(u,o,m));case"normalization":return n(()=>kf(u,o,m));case"ragged":return n(()=>Cf(u,o,m));case"reduction":return n(()=>Df(u,o,m));case"slice_join":return n(()=>zf(u,o,m));case"sparse":return n(()=>Lf(u,o,m));case"spectral":return n(()=>$f(u,o,m));case"string":return n(()=>Pf(u,o,m));case"transformation":return n(()=>Vf(u,o,m));case"hash_table":return _f(u,o,m,s);case"custom":const p=Xr(u.op);if(p&&p.customExecutor)return p.customExecutor(new pf(u,o,m));throw TypeError(`Custom op ${u.op} is not registered.`);default:throw TypeError(`Unknown op '${u.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return X(i)?i.then(u=>[].concat(u)):[].concat(i)}class qe{constructor(e={},t={},s={},n={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=n,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(a,e,t,s){const n=new Set,i=[];let u=null,o=null;const m=new Set,p=new Set(Object.keys(a).map(c=>O(c)[0]));s=s||[];const l=new Set(s.map(c=>O(c.name)[0])),d=[...e];for(;d.length>0;){const c=d.pop();if((P(c)||Uf(c)||qf(c))&&u==null&&(u=c,o=u.children.map(f=>f.name).filter(f=>n.has(f))),n.add(c.name),t[c.name]==null&&!p.has(c.name)&&!l.has(c.name)){if(c.inputs.length===0){i.push(c.name);continue}c.inputs.forEach(f=>{m.has(f.name)||(m.add(f.name),d.push(f))})}}return{inputs:a,outputs:e,usedNodes:n,missingInputs:i,dynamicNode:u,syncInputs:o}}function Ff(a,e){const{usedNodes:t,inputs:s}=e,n=Object.keys(s).map(h=>O(h)[0]).map(h=>a.nodes[h]),i=a.initNodes||[],u=h=>t.has(typeof h=="string"?h:h.name);function o(h){return[...new Map(h.map(g=>[g.name,g])).values()]}const m=o([...n,...a.weights,...i]).filter(u),p=o([...m,...Object.values(a.nodes)]).filter(u),l=new Map(p.map(h=>[h.name,h])),d={};for(const h of p){d[h.name]=d[h.name]||0;for(const g of h.children)u(g)||(d[g.name]=Number.POSITIVE_INFINITY),d[g.name]=(d[g.name]||0)+1}const c=Object.entries(d).filter(([,h])=>h===0).map(([h])=>h),f=[...c];for(;c.length>0;){const h=c.pop(),g=l.get(h);for(const w of g.children.filter(u))--d[w.name]===0&&(f.push(w.name),c.push(w.name))}const N=f.map(h=>l.get(h)),y=xf(N,m);return Rf(y,m),y}function xf(a,e){const t=new Map(a.map(u=>[u.name,u])),s=e.map(u=>u.name),n=new Set(s);for(;s.length>0;){const u=s.pop(),o=t.get(u);for(const m of o.children)!t.has(m.name)||n.has(m.name)||(n.add(m.name),s.push(m.name))}return a.filter(u=>n.has(u.name))}class G extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Rf(a,e){const t=new Map(a.map((o,m)=>[o.name,m])),s=new Set(e.map(o=>o.name)),n=o=>s.has(typeof o=="string"?o:o.name),i=new Set(a.map(o=>o.name)),u=o=>i.has(typeof o=="string"?o:o.name);for(const o of a){for(const m of o.children.filter(u)){if(!t.has(m.name))throw new G(`Child ${m.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(m.name))throw new G(`Node ${o.name} is scheduled to run after its child ${m.name}.`)}if(!n(o))for(const m of o.inputs){if(!t.has(m.name))throw new G(`Input ${m.name} of node ${o.name} is unreachable.`);if(t.get(m.name)>t.get(o.name))throw new G(`Node ${o.name} is scheduled to run before its input ${m.name}.`)}}}function jf(a){const e=new Map(a.map((o,m)=>[o.name,m])),t=Number.MAX_SAFE_INTEGER,s=a.map((o,m)=>P(o)?t:m),n=o=>{const m=s[e.get(o.name)];return m??-1},i=a.map((o,m)=>o.children.map(n).reduce((p,l)=>Math.max(p,l),s[m])),u=new Map;for(let o=0;o<a.length;++o){const m=i[o];if(m===t)continue;const p=a[o],l=a[m];u.has(l.name)||u.set(l.name,[]),u.get(l.name).push(p)}return u}const Bf=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Hf=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Wf=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function P(a){return Bf.has(a.op)}function Uf(a){return Hf.has(a.op)}function qf(a){return Wf.has(a.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(n=>n.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new M(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),n=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(e,t){const s=Ge(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:i,syncInputs:u}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${u}]`);if(n.length>0){const p=t.map(d=>d.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${p}] from the provided inputs [${l}]. Missing the following inputs: [${n}]`)}const o=Ff(this.graph,s),m=jf(o);return{orderedNodes:o,nodeLiveUntilMap:m}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return E(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const n=s.map(c=>this.graph.nodes[O(c)[0]]),i=t.map(c=>O(c)[0]),u=new Set(i);let o=i.map(c=>this.graph.nodes[c]);o.length===0&&(o=this._outputs);const m=this.getCompilationKey(n,o);let p=this.compiledMap.get(m);p==null&&(p=this.compile(e,o),this.compiledMap.set(m,p));try{this.keepIntermediateTensors=C().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}const l={},d={};return I(()=>{const c=new qe(this.weightMap,l,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(g=>{const[w,D]=O(g,c),b=[];b[D]=e[g],f[w]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(b))});const N=this.getFrozenTensorIds(f),{orderedNodes:y,nodeLiveUntilMap:h}=p;for(const g of y){if(f[g.name])continue;const w=Ue(g,f,c,this._resourceManager);if(X(w))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);f[g.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(g,f,c,N,u,h.get(g.name))}return this.parent==null&&c.dispose(N),t.map(g=>T(g,f,c))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(n=>n.id)));return new Set(t)}checkTensorForDisposal(e,t,s,n,i,u,o){if(!(P(t)||u.has(e))){for(const m of s[e])m!=null&&(o[m.id]=(o[m.id]||0)+t.children.length);for(const m of t.inputs){if(P(m))continue;const p=Re(m.name,s,n);if(p!=null)for(const l of p){if(!l||l.kept||i.has(l.id))continue;const d=o[l.id];d===1?(l.dispose(),delete o[l.id]):d!=null&&o[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,n,i,u){function o(m){return P(m)||i.has(m.name)}if(!(P(e)||u==null))for(const m of u){if(o(m))continue;const p=Re(m.name,t,s);for(const l of p)!l||l.kept||n.has(l.id)||l.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,n={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=C().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}const u=new qe(this.weightMap,n,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,u,t,s),m=t.map(c=>T(c,o,u)),p=m.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id),d=new Set([...p,...l,...this.weightIds]);return Object.values(o).forEach(c=>{c.forEach(f=>{f&&!f.isDisposed&&!d.has(f.id)&&f.dispose()})}),this.parent==null&&u.dispose(d),m}async executeFunctionAsync(e,t,s){const n=e.reduce((i,u,o)=>(i[this.inputs[o].name]=u,i),{});return this._executeAsync(n,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,n){const i=Object.keys(e),u=i.map(b=>this.graph.nodes[O(b)[0]]),o=s.map(b=>O(b)[0]),m=new Set(o);let p=o.map(b=>this.graph.nodes[b]);p.length===0&&(p=this._outputs);const{usedNodes:l,missingInputs:d,dynamicNode:c,syncInputs:f}=Ge(e,p,this.weightMap,this._initNodes),N=[...u,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),y=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[x,W]=O(b),U=[];U[W]=e[b],y[x]=U});const h={},g=this.getFrozenTensorIds(y),w={};for(;N.length>0;){const b=this.processStack(u,N,t,y,w,g,m,h,l);await Promise.all(b)}c==null&&!n&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const D=p.filter(b=>!P(b)&&!T(b.name,y,t)).map(b=>b.name);if(D.length>0){let b="";throw c!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${D}] from the provided inputs [${i}]. Consider providing the following inputs: [${d}]. ${b}`)}return y}processStack(e,t,s,n,i,u,o,m,p){const l=[];for(;t.length>0;){const d=t.pop();s.currentContext=d.contexts;let c="";if(d.node.op==="Enter"&&r("isConstant",d.node,n,s)&&([c]=z(d.node.name,s)),n[d.node.name]==null){const f=Ue(d.node,n,s,this._resourceManager);c||([c]=z(d.node.name,s));const N=s.currentContext;X(f)?l.push(f.then(y=>(n[c]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(y)),s.currentContext=N,this.checkTensorForDisposal(c,d.node,n,s,u,o,m),this.processChildNodes(d.node,t,s,n,i,p),y))):(n[c]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(f)),this.checkTensorForDisposal(c,d.node,n,s,u,o,m),this.processChildNodes(d.node,t,s,n,i,p))}else this.processChildNodes(d.node,t,s,n,i,p)}return l}processChildNodes(e,t,s,n,i,u){e.children.forEach(o=>{const[m]=z(o.name,s);i[m]||!u.has(o.name)||(o.op==="Merge"?o.inputNames.some(p=>!!T(p,n,s))&&(i[m]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(p=>!!T(p,n,s))&&(i[m]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[n]=O(t),i=this.graph.nodes[n];if(i.attrParams.shape&&i.attrParams.shape.value){const u=i.attrParams.shape.value,o=u.length===s.shape.length&&s.shape.every((m,p)=>u[p]===-1||u[p]===m);k(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${u}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&k(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const n={};for(const i in e){const u=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];u!=null?n[u.name]=e[i]:n[i]=e[i]}return n}checkInputs(e){const t=Object.keys(e).filter(s=>{const[n]=O(s);return this.graph.nodes[n]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,n;const i=(n=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||n===void 0?void 0:n[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=O(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Gf{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kf="?tfjs-format=file",Qf="model.json";class Le{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Ae){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new Gf}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return X(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await lo(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(n=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=n,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new M(je.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=je.Instance.transformGraph(e.modelInitializer);this.initializer=new M(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof ne?[e]:e,s={};return t.forEach((n,i)=>s[this.structuredOutputKeys[i]]=n),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof ne)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const u in i){const o=i[u];o.resourceId!=null&&(e[u]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((i,u)=>{var o,m,p;const l=(p=(m=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||m===void 0?void 0:m[u])===null||p===void 0?void 0:p.resourceId;return l!=null?i[u]=this.resourceIdToCapturedInput[l]:i[u]=e[n++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let n=0;n<s.length;n++){const i=s[n],u=t[i];this.resourceIdToCapturedInput[u.resourceId]=e[n]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&xr(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Jf(a,e={},t=Ae){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof a=="string"&&(a=Xf(a));const s=new Le(a,e,t);return await s.load(),s}function Zf(a){if(a==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(a instanceof Array){const[s,n]=a;if(!s)throw new Error("modelJSON must be the first element of the array");if(!n||!(n instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const i=co(s.weightsManifest),u=ho(s,i,n);e=Fe(u)}else if("load"in a)e=a;else if("modelTopology"in a&&"weightSpecs"in a&&"weightData"in a)e=Fe(a);else throw new Error("Unknown model format");const t=new Le(e);return t.load(),t}function Xf(a){return a.endsWith("/")||(a=a+"/"),`${a}${Qf}${Kf}`}/** @license See the LICENSE file. */const en="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class tn extends Ie{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(n=>(n.endsWith("\r")&&(n=n.slice(0,-1)),n))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const K='"',H=Symbol("out"),Ke=Symbol("field"),Q=Symbol("quote"),re=Symbol("quoteafterquote"),Qe=Symbol("quoteinquote");class an extends Ie{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&k(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((n,i)=>(n[i]=n[i]+1||1,n),{}),s=Object.keys(t).filter(n=>t[n]>1);if(k(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const n of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(n)===-1)throw new Error('The key "'+n+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new tn(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(k(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},n={};for(let i=0;i<this.fullColumnNames.length;i++){const u=this.fullColumnNames[i],o=this.columnConfigs?this.columnConfigs[u]:null;if(!(this.configuredColumnsOnly&&!o)){const m=t[i];let p=null;if(m==="")if(o&&o.default!==void 0)p=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${u} is empty in this line: ${e}`);p=void 0}else{const l=Number(m);if(isNaN(l))o&&o.dtype==="bool"?p=this.getBoolean(m):p=m;else if(!o||!o.dtype)p=l;else switch(o.dtype){case"float32":p=l;break;case"int32":p=Math.floor(l);break;case"bool":p=this.getBoolean(m);break;default:p=l}}o&&o.isLabel?n[u]=p:s[u]=p}}return Object.keys(n).length===0?s:{xs:s,ys:n}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let n=0;const i=e.length;let u=H;for(let o=0;o<i;o++)switch(u){case H:switch(e.charAt(o)){case K:n=o+1,u=Q;break;case this.delimiter:if(n=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),u=H;break;default:u=Ke,n=o;break}break;case Ke:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(n,o)),u=H,n=o+1;break}break;case Q:switch(e.charAt(o)){case K:u=re;break}break;case re:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(n,o-1)),u=H,n=o+1;break;case K:u=Q;break;default:u=Qe;break}break;case Qe:switch(e.charAt(o)){case K:u=Q;break}break}if(u===re?s.push(e.substring(n,i-1)):s.push(e.substring(n)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class $e extends ae{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!C().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new $e(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const n=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(n,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const n=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(n,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(n=>{const i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&n({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(i),n({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((n,i)=>s.set(n,i*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(fo(t));return s.set(e,s.length-e.length),V(s,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Pe extends ae{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=_e([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,n=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-s)/2,u=(1-n)/2,o=i+s,m=n+u;this.cropBox=Z([u,i,m,o],[1,4])}else this.cropBox=Z([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!C().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new Pe(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&k(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=yo(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return I(()=>{const t=Oe(we(e,"float32"),0);let s;s=ve.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const n=s.shape;return A(s,n.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class sn{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class rn extends ae{split(e){return new Yf(this,e)}}class Yf extends rn{constructor(e,t){super(),this.upstream=e,this.impl=new Mf(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Mf extends Rr{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ey extends ae{decodeUTF8(){return new ty(this)}}class ty extends rn{constructor(e){super(),this.upstream=e,this.impl=new ay(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class ay extends Rr{constructor(e){if(super(),this.upstream=e,C().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return C().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class nn extends ey{constructor(e,t={}){super(),this.file=e,this.options=t,k(e instanceof Uint8Array||(C().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,n)));else{const i=new FileReader;i.onload=o=>{let m=i.result;if(m instanceof ArrayBuffer&&(m=new Uint8Array(m)),!(m instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(m)},i.onabort=o=>s(new Error("Aborted")),i.onerror=o=>s(new Error(o.type));const u=this.file.slice(this.offset,n);i.readAsArrayBuffer(u)}this.offset=n}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function sy(a,e={},t){let s,n;typeof a=="string"?s=a:(s=a.url,n=ry(a));const i=await go(s,n);if(i.ok){const u=new Uint8Array(await i.arrayBuffer());return new nn(u,e)}else throw new Error(i.statusText)}const ry=a=>({method:a.method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function on(a){return typeof a=="string"&&a.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class un extends sn{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(on(this.input)&&C().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new nn(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class mn extends sn{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return on(this.url)?new un(this.url,this.fileOptions).iterator():sy(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function ny(a,e={}){return new an(new mn(a),e)}function iy(a){const e=jr(a);return Br(async()=>e)}function oy(a){return Br(async()=>{const e=await a();return jr(()=>e.next())})}async function uy(a,e){return Pe.create(a,e)}async function my(a){return $e.create(a)}/** @license See the LICENSE file. */const pn="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const py=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:an,Dataset:Ie,FileDataSource:un,TextLineDataset:tn,URLDataSource:mn,array:No,csv:ny,func:iy,generator:oy,microphone:my,version_data:pn,webcam:uy,zip:bo},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const ln="4.22.0";/** @license See the LICENSE file. */const cn="4.22.0";/** @license See the LICENSE file. */const ly="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cy={"tfjs-core":Wr,"tfjs-backend-cpu":ln,"tfjs-backend-webgl":cn,"tfjs-data":pn,"tfjs-layers":Hr,"tfjs-converter":en,tfjs:ly},hy=Object.freeze(Object.defineProperty({__proto__:null,Abs:To,Acos:So,Acosh:wo,AdadeltaOptimizer:Oo,AdagradOptimizer:vo,AdamOptimizer:_o,AdamaxOptimizer:Ao,Add:Io,AddN:Eo,All:ko,Any:Co,ArgMax:Do,ArgMin:zo,Asin:Lo,Asinh:$o,Atan:Po,Atan2:Vo,Atanh:Fo,AvgPool:xo,AvgPool3D:Ro,AvgPool3DGrad:jo,AvgPoolGrad:Bo,BatchMatMul:Ho,BatchToSpaceND:Wo,Bincount:Uo,BitwiseAnd:qo,BroadcastArgs:Go,BroadcastTo:Ko,Callback:Jr,CallbackList:Qo,Cast:Jo,Ceil:Zo,ClipByValue:Xo,Complex:Yo,ComplexAbs:Mo,Concat:eu,Conv2D:tu,Conv2DBackpropFilter:au,Conv2DBackpropInput:su,Conv3D:ru,Conv3DBackpropFilterV2:nu,Conv3DBackpropInputV2:iu,Cos:ou,Cosh:uu,CropAndResize:mu,Cumprod:pu,Cumsum:lu,CustomCallback:cu,DataStorage:du,DenseBincount:hu,DepthToSpace:fu,DepthwiseConv2dNative:yu,DepthwiseConv2dNativeBackpropFilter:gu,DepthwiseConv2dNativeBackpropInput:Nu,Diag:bu,Dilation2D:Tu,Dilation2DBackpropFilter:Su,Dilation2DBackpropInput:wu,Draw:Ou,get ENV(){return vu},EarlyStopping:Zr,Einsum:_u,Elu:Au,EluGrad:Iu,Environment:Eu,Equal:ku,Erf:Cu,Exp:Du,ExpandDims:zu,Expm1:Lu,FFT:$u,Fill:Pu,FlipLeftRight:Vu,Floor:Fu,FloorDiv:xu,FromPixels:Ru,FusedBatchNorm:ju,FusedConv2D:Bu,FusedDepthwiseConv2D:Hu,GPGPUContext:Wu,GatherNd:Uu,GatherV2:qu,GraphModel:Le,Greater:Gu,GreaterEqual:Ku,History:Qu,IFFT:Ju,Identity:Zu,Imag:Xu,InputSpec:Yu,IsFinite:Mu,IsInf:em,IsNan:tm,KernelBackend:am,LRN:sm,LRNGrad:rm,LayerVariable:nm,LayersModel:ge,LeakyRelu:im,Less:om,LessEqual:um,LinSpace:mm,Log:pm,Log1p:lm,LogSoftmax:cm,LogicalAnd:dm,LogicalNot:hm,LogicalOr:fm,LogicalXor:ym,LowerBound:gm,MathBackendCPU:Nm,MathBackendWebGL:bm,MatrixBandPart:Tm,Max:Sm,MaxPool:wm,MaxPool3D:Om,MaxPool3DGrad:vm,MaxPoolGrad:_m,MaxPoolWithArgmax:Am,Maximum:Im,Mean:Em,Min:km,Minimum:Cm,MirrorPad:Dm,Mod:zm,MomentumOptimizer:Lm,Multinomial:$m,Multiply:Pm,Neg:Vm,NonMaxSuppressionV3:Fm,NonMaxSuppressionV4:xm,NonMaxSuppressionV5:Rm,NotEqual:jm,OP_SCOPE_SUFFIX:Ze,OneHot:Bm,OnesLike:Hm,Optimizer:Wm,OptimizerConstructors:Um,Pack:qm,PadV2:Gm,Pool:Km,Pow:Qm,Prelu:Jm,Prod:Zm,RMSPropOptimizer:Xm,RNN:Ne,RaggedGather:Ym,RaggedRange:Mm,RaggedTensorToTensor:ep,Range:tp,get Rank(){return ap},Real:sp,RealDiv:rp,Reciprocal:np,get Reduction(){return ip},Relu:op,Relu6:up,Reshape:mp,ResizeBilinear:pp,ResizeBilinearGrad:lp,ResizeNearestNeighbor:cp,ResizeNearestNeighborGrad:dp,Reverse:hp,RotateWithOffset:fp,Round:yp,Rsqrt:gp,SGDOptimizer:Np,ScatterNd:bp,SearchSorted:Tp,Select:Sp,Selu:wp,Sequential:Je,Sigmoid:Op,Sign:vp,Sin:_p,Sinh:Ap,Slice:Ip,Softmax:Ep,Softplus:kp,SpaceToBatchND:Cp,SparseFillEmptyRows:Dp,SparseReshape:zp,SparseSegmentMean:Lp,SparseSegmentSum:$p,SparseToDense:Pp,SplitV:Vp,Sqrt:Fp,Square:xp,SquaredDifference:Rp,StaticRegexReplace:jp,Step:Bp,StridedSlice:Hp,StringNGrams:Wp,StringSplit:Up,StringToHashBucketFast:qp,Sub:Gp,Sum:Kp,SymbolicTensor:Qp,Tan:Jp,Tanh:Zp,Tensor:ne,TensorBuffer:Xp,TensorScatterUpdate:Yp,Tile:Mp,TopK:el,Transform:tl,Transpose:al,Unique:sl,Unpack:rl,UnsortedSegmentSum:nl,UpperBound:il,Variable:ol,ZerosLike:ul,_FusedMatMul:ml,abs:Xe,acos:Ye,acosh:Me,add:et,addN:tt,all:at,any:st,argMax:rt,argMin:nt,asin:it,asinh:ot,atan:ut,atan2:mt,atanh:pt,avgPool:lt,avgPool3d:ct,backend:pl,backend_util:ll,basicLSTMCell:dt,batchNorm:ht,batchNorm2d:ft,batchNorm3d:yt,batchNorm4d:gt,batchToSpaceND:Nt,bincount:bt,bitwiseAnd:Tt,booleanMaskAsync:St,broadcastArgs:wt,broadcastTo:Ot,broadcast_util:cl,browser:dl,buffer:vt,callbacks:Sh,cast:we,ceil:_t,clipByValue:At,clone:Se,complex:It,concat:ee,concat1d:Et,concat2d:kt,concat3d:Ct,concat4d:Dt,constraints:yc,conv1d:zt,conv2d:Lt,conv2dTranspose:$t,conv3d:Pt,conv3dTranspose:Vt,copyRegisteredKernels:hl,cos:Ft,cosh:xt,cosineWindow:Rt,cumprod:jt,cumsum:Bt,customGrad:fl,data:py,denseBincount:Ht,deprecationWarn:yl,depthToSpace:Wt,depthwiseConv2d:Ut,deregisterOp:Oh,device_util:gl,diag:qt,dilation2d:Gt,disableDeprecationWarnings:Nl,dispose:xr,disposeVariables:bl,div:Kt,divNoNan:Qt,dot:Jt,dropout:Zt,einsum:Xt,elu:Yt,enableDebugMode:Tl,enableProdMode:Sl,enclosingPowerOfTwo:Mt,engine:wl,ensureShape:ea,env:C,equal:ta,erf:aa,euclideanNorm:sa,exp:ra,expandDims:Oe,expm1:na,eye:ia,fft:oa,fill:ua,findBackend:Ol,findBackendFactory:vl,floor:ma,floorDiv:pa,forceHalfFloat:_l,fused:la,gather:ca,gatherND:da,gather_util:Al,getBackend:Il,getGradient:El,getKernel:kl,getKernelsForBackend:Cl,gpgpu_util:Dl,grad:zl,grads:Ll,greater:ha,greaterEqual:fa,ifft:ya,imag:ga,image:ve,inTopKAsync:Na,initializers:zc,input:Ur,io:Ae,irfft:ba,isFinite:Ta,isInf:Sa,isNaN:wa,keep:E,kernel_impls:$l,layers:Xd,leakyRelu:Oa,less:va,lessEqual:_a,linalg:Aa,linspace:Ia,loadGraphModel:Jf,loadGraphModelSync:Zf,loadLayersModel:Pl,localResponseNormalization:Ea,log:ka,log1p:Ca,logSigmoid:Da,logSoftmax:za,logSumExp:La,logicalAnd:$a,logicalNot:Pa,logicalOr:Va,logicalXor:Fa,losses:xa,lowerBound:Ra,matMul:ja,math:Vl,max:Ba,maxPool:Ha,maxPool3d:Wa,maxPoolWithArgmax:Ua,maximum:qa,mean:Ga,memory:Fl,meshgrid:Ka,metrics:hh,min:Qa,minimum:Ja,mirrorPad:Za,mod:Xa,model:Lc,models:fh,moments:Ya,movingAverage:Ma,mul:es,multiRNNCell:ts,multinomial:as,neg:ss,nextFrame:xl,norm:rs,notEqual:ns,oneHot:is,ones:os,onesLike:us,op:ms,outerProduct:ps,pad:ls,pad1d:cs,pad2d:ds,pad3d:hs,pad4d:fs,pool:ys,pow:gs,prelu:Ns,print:bs,prod:Ts,profile:Rl,raggedGather:Ss,raggedRange:ws,raggedTensorToTensor:Os,rand:vs,randomGamma:_s,randomNormal:As,randomStandardNormal:Is,randomUniform:Es,randomUniformInt:ks,range:Cs,ready:jl,real:Ds,reciprocal:zs,registerBackend:Bl,registerCallbackConstructor:Pc,registerGradient:Hl,registerKernel:Wl,registerOp:wh,regularizers:bh,relu:Ls,relu6:$s,removeBackend:Ul,reshape:A,reverse:Ps,reverse1d:Vs,reverse2d:Fs,reverse3d:xs,reverse4d:Rs,rfft:js,round:Bs,rsqrt:Hs,scalar:$,scatterND:Ws,scatter_util:ql,searchSorted:Us,selu:qs,separableConv2d:Gs,sequential:$c,serialization:Gl,setBackend:Kl,setPlatform:Ql,setWebGLContext:Jl,setdiff1dAsync:Ks,shared:Zl,sigmoid:Qs,sign:Js,signal:Zs,sin:Xs,sinh:Ys,slice:te,slice1d:Ms,slice2d:er,slice3d:tr,slice4d:ar,slice_util:Xl,softmax:sr,softplus:rr,spaceToBatchND:nr,sparse:ir,sparseToDense:or,spectral:ur,split:mr,sqrt:pr,square:lr,squaredDifference:cr,squeeze:dr,stack:R,step:hr,stridedSlice:fr,string:yr,sub:gr,sum:Nr,sumOutType:Yl,tan:br,tanh:Tr,tensor:V,tensor1d:_e,tensor2d:Z,tensor3d:Sr,tensor4d:wr,tensor5d:Or,tensor6d:vr,tensorScatterUpdate:_r,tensor_util:Ml,test_util:ec,tidy:I,tile:Ar,time:tc,topk:Ir,train:ac,transpose:Er,truncatedNormal:kr,unique:Cr,unregisterGradient:sc,unregisterKernel:rc,unsortedSegmentSum:Dr,unstack:j,upcastType:nc,upperBound:zr,util:ic,valueAndGrad:oc,valueAndGrads:uc,variable:Lr,variableGrads:mc,version:cy,version_converter:en,version_core:Wr,version_cpu:ln,version_layers:Hr,version_webgl:cn,webgl:pc,webgl_util:lc,where:$r,whereAsync:Pr,zeros:Vr,zerosLike:Fr},Symbol.toStringTag,{value:"Module"}));export{hy as d};
