(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}})();class g{constructor(e,t,n,r){this.name=e,this.trickTakingRank=t,this.score=n,this.ttRankAbove=r}toString(){return this.name}toStringShort(){return this.name[0]}static rankEquals(e,t){return e.name===t.name}}class h{constructor(e,t){this.name=e,this.rankForTrumpPreference=t}toString(){return this.name}toStringShort(){return this.name[0]}static suitEquals(e,t){return e.name===t.name}}class u{constructor(e,t,n){this.suit=e,this.rank=t,this.index=n}toString(){return`${this.rank.toString()} of ${this.suit.toString()}`}toStringShort(){return`${this.rank.toStringShort()}${this.suit.toStringShort()}`}nextCardUp(e){const t=this.rank.ttRankAbove,n=this.suit,r=e.filter(s=>h.suitEquals(s.suit,n)&&s.rank.trickTakingRank===t);return r.length!==1&&console.log(`Error in nextCardUp: ${r}`),r[0]}static cardEquals(e,t){return g.rankEquals(e.rank,t.rank)&&h.suitEquals(e.suit,t.suit)}static cardFromIndex(e,t){const n=t.filter(r=>r.index===e);return n.length!==1&&console.log(`Error in cardFromIndex: ${n}`),n[0]}static singleHighestCard(e){const t=Math.max(...e.map(r=>r.rank.trickTakingRank)),n=e.filter(r=>r.rank.trickTakingRank===t);return n.length>1&&console.log(`Too many highest cards: ${n}`),n[0]}}const v=[...Array.from({length:9},(a,e)=>{const t=e+2;return new g(t!==10?String(t):"T",t,t,t+1)}),new g("J",11,12,12),new g("Q",12,15,13),new g("K",13,18,14),new g("A",14,1,4)],T=[new h("Diamonds",0),new h("Hearts",1),new h("Spades",2),new h("Clubs",3)],L=T[0];class y{constructor(e=4){this.minRank=e,this.cards=[],this.cards=this.getFullPack()}getFullPack(){const e=[];let t=0;for(const n of v)if(!(n.trickTakingRank<this.minRank)){n.name==="A"&&(n.ttRankAbove=this.minRank);for(const r of T){let s=new u(r,n,t);e.push(s),t++}}return e}getCard(e){for(const t of this.getFullPack())if(t.toStringShort()===e)return t;throw new Error(`Failed to locate card: ${e}`)}static shuffle(e){for(let t=e.length-1;t>0;t--){const n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}isEmpty(){return this.cards.length===0}filterOut(e){return this.cards.filter(n=>!e.some(r=>u.cardEquals(n,r)))}get count(){return this.cards.length}}const k=["player","comp1","comp2"];class F{constructor(e,t,n,r,s,i){this.displayName=e,this.name=t,this.hand=n,this.score=r,this.agent=s,this.positionIndex=i}}const x={chooseMove:(a,e)=>{const t=Math.floor(Math.random()*e.length);return e[t]}};class H{constructor(e){this.playerNames=e,this.players=[],this.pack=new y,this.cardsPerHand=12,this.trickInProgress=[],this.previousTrick=[],this.groundings=[],this.spoils=[],this.deadCards=[],this.ladders=this.getStartingLadders(),this.trumpSuit=L,this.currentState="initialiseGame",this.handNumber=0;const t=["player","comp1","comp2"],n=["human",x,x];this.players=e.map((r,s)=>new F(r,t[s],[],0,n[s],s));for(const r of e)this.players.push();this.dealerIndex=0,this.currentPlayerIndex=0,this.trickIndex=0,this.finalTrickWinnerIndex=-1}increment(){switch(this.currentState){case"initialiseGame":this.dealCards(this.pack);break;case"playCard":this.computerMove();break;case"trickComplete":this.resetTrick();break;case"handComplete":this.updateScores(),this.dealerIndex=this.getNextPlayerIndex(this.dealerIndex),this.dealCards(this.pack);break}}get trickInProgressCards(){return this.trickInProgress.map(([e,t])=>e)}get currentLedSuit(){const e=this.trickInProgressCards;return e.length===0?null:e[0].suit}get legalMoveIndices(){let e;const t=this.currentPlayerHand,n=this.currentLedSuit;return n===null?e=t:(e=t.filter(r=>h.suitEquals(r.suit,n)),e.length===0&&(e=t)),e.map(r=>r.index)}getPlayedCard(e,t){const n=t.filter(([s,i])=>i.name===e),r=n.length;return r===1?n[0][0]:(r>1&&console.log(`getPlayedCard error: ${n}`),null)}get currentPlayer(){return this.players[this.currentPlayerIndex]}get currentPlayerHand(){return this.currentPlayer.hand}get numPlayers(){return this.players.length}getNextPlayerIndex(e){return(e+1)%this.numPlayers}get trickWinnerPlayer(){return this.trickInProgress.filter(([n,r])=>u.cardEquals(n,this.winningCard))[0][1]}getStartingLadders(){return["5D","6H","7S","8C"].map(e=>[this.pack.getCard(e),null])}get ladderCards(){return this.ladders.map(([e,t])=>e)}trumpSuitFromLadders(){const e=this.ladderCards,t=Math.min(...e.map(i=>i.rank.trickTakingRank)),n=e.filter(i=>i.rank.trickTakingRank===t);if(n.length===1)return n[0].suit;const r=Math.max(...e.map(i=>i.suit.rankForTrumpPreference)),s=e.filter(i=>i.suit.rankForTrumpPreference===r);if(s.length===1)return s[0].suit;throw new Error("Error determining trump suit")}incrementRungCount(e){}updateLadders(e){let t=this.trickInProgressCards;this.isPenultimateTrick&&(t=t.concat(this.spoils));let n;for(;(n=this.ladderCards.filter(r=>t.filter(s=>u.cardEquals(s,r.nextCardUp(this.pack.getFullPack()))).length>0)).length>0;){let r=n[0],s=r.nextCardUp(this.pack.getFullPack());this.ladders=this.ladders.filter(([i,o])=>!u.cardEquals(i,r)),this.ladders.push([s,e]),t=t.filter(i=>!u.cardEquals(i,s)),t.push(r),this.incrementRungCount(r.suit)}return t}get winningCard(){const e=this.trickInProgress.filter(([n,r])=>h.suitEquals(n.suit,this.trumpSuit));let t;if(e.length>0)t=u.singleHighestCard(e.map(([n,r])=>n));else{const n=this.trickInProgress.filter(([r,s])=>h.suitEquals(r.suit,this.currentLedSuit));t=u.singleHighestCard(n.map(([r,s])=>r))}return t}get isPenultimateTrick(){return this.trickIndex===this.cardsPerHand-2}get isFinalTrick(){return this.trickIndex===this.cardsPerHand-1}get handNotFinished(){return this.players.map(e=>e.hand).some(e=>e.length>0)}computerMove(){const e=this.currentPlayer.agent;if(e==="human")return console.log("Error: trying to move for a human"),-20;const t=this.legalMoveIndices,n=e.chooseMove(this,t),r=u.cardFromIndex(n,this.pack.getFullPack());return this.playCard(r)||console.log("Error playing card"),n}resetTrick(){const e=this.trickWinnerPlayer;this.currentPlayerIndex=e.positionIndex,this.updateLadders(e),this.isFinalTrick&&(this.finalTrickWinnerIndex=e.positionIndex),this.previousTrick=this.trickInProgress,this.trickInProgress=[],this.trickIndex++,this.handNotFinished?this.currentState="playCard":this.currentState="handComplete"}dealCards(e,t=12){const n=Math.ceil(t/2),r=this.pack.filterOut(this.ladderCards);if(y.shuffle(r),this.handNumber==0)for(let s=0;s<2;s++){const i=r.pop();i?this.groundings.push(i):console.log("Deal error! ran out of cards before groundings")}for(let s=0;s<t;s++){for(let i=0;i<3;i++){const o=r.pop();o&&this.giveCardToPlayer(i,o)}if(s===n-1){this.deadCards=[];for(let i=0;i<2;i++){const o=r.pop();o?this.deadCards.push(o):console.log("Deal error! ran out of cards before deads")}for(let i=0;i<2;i++){const o=this.groundings.pop();o?r.push(o):console.log("Deal error! ran out of cards before shuffling groundings")}y.shuffle(r)}}this.spoils=[];for(let s=0;s<2;s++){const i=r.pop();i?this.spoils.push(i):console.log("Deal error! ran out of cards before spoils")}console.log("Empty pack:"),console.log(r),this.trumpSuit=this.trumpSuitFromLadders(),this.currentState="playCard",this.currentPlayerIndex=this.getNextPlayerIndex(this.dealerIndex),this.handNumber++}giveCardToPlayer(e,t){this.players[e].hand.push(t)}getPlayerHand(e){return this.players[e].hand??[]}playCard(e){if(!this.legalMoveIndices.includes(e.index))return console.log(`Error: Cannot play illegal card ${e}`),!1;const t=this.currentPlayer,n=t.hand;if(!n)return console.log("Error: I couldn't find a hand!"),!1;const r=n.findIndex(o=>o.rank===e.rank&&o.suit===e.suit);if(r<0)return!1;const[s]=n.splice(r,1);if(this.trickInProgress.push([s,t]),this.trickInProgress.length===this.numPlayers)return this.currentState="trickComplete",!0;const i=this.getNextPlayerIndex(this.currentPlayerIndex);return this.currentPlayerIndex=i,!0}updateScores(){}getStateForUI(){return{hands:{comp1:[],player:this.getPlayerHand(0),comp2:[]},trumps:this.trumpSuit,played:Object.fromEntries(k.map(e=>[e,this.getPlayedCard(e,this.trickInProgress)])),previous:Object.fromEntries(k.map(e=>[e,this.getPlayedCard(e,this.previousTrick)])),ladder:{...Object.fromEntries(k.map(e=>[e,this.ladders.filter(([t,n])=>n!==null&&n.name===e).map(([t,n])=>t)])),neutral:this.ladders.filter(([e,t])=>t===null).map(([e,t])=>e)},penultimate:this.isFinalTrick||this.isPenultimateTrick?this.spoils:[],game_state:this.currentState,whose_turn:this.currentPlayer.name,getCard:e=>this.pack.getCard(e),playCard:e=>(this.playCard(e),this.getStateForUI()),increment:()=>(this.increment(),this.getStateForUI()),hand_number:this.handNumber,scores:{comp1:0,player:0,comp2:0},scores_previous:{comp1:0,player:0,comp2:0},score_details:{},holding_bonus:{comp1:{},player:{},comp2:{}},dead:[],escalations:-1,advance:"C"}}}class ${constructor(e){this.pack=new y,this.state=new H(e),this.state.increment()}getGameState(){return this.state}getGameStateForUI(){return this.state.getStateForUI()}}const M={2:0,3:1,4:2,5:3,6:4,7:5,8:6,9:7,T:8,J:9,Q:10,K:11,A:12},w={S:0,H:1,C:2,D:3},_=72,R=96;function m(a,e){const t=document.createElement("span");t.className="card";const n=a.match(/^([0-9TJQKA])([SHDC])$/);if(n){const[,r,s]=n,i=M[r],o=w[s];t.style.backgroundPosition=`-${i*_}px -${o*R}px`}else t.innerText=a,t.style.background="#ccc";return e&&(t.onclick=()=>e()),t}function C(a){const e=document.createElement("span");e.className="suit-icon";const t=a.match(/^([SHDC])$/),n=32;if(t){const[,r]=t,s=w[r];e.style.backgroundPosition=`32px -${s*n}px`}else e.innerText="",e.style.background="#ccc";return e}function N(a,e){const t=a.playCard(e);f(t)}async function f(a){console.log(a);const e=document.getElementById("player-hand"),t=a.hands.player;t.sort((c,l)=>100*(c.suit.rankForTrumpPreference-l.suit.rankForTrumpPreference)+(c.rank.trickTakingRank-l.rank.trickTakingRank)),e.innerHTML="",t.forEach(c=>{e.appendChild(m(c.toStringShort(),a.whose_turn==="player"?()=>N(a,c):void 0))}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`played-${c}`);l.innerHTML="";const d=a.played[c],p=m(d!==null?d.toStringShort():"");p.classList.add("played-card"),l.appendChild(p)}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`prev-${c}`);l.innerHTML="";const d=a.previous[c],p=m(d!==null?d.toStringShort():"");p.classList.add("played-card"),l.appendChild(p)}),["player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`hb-${c}`);l.innerHTML="";const d=a.holding_bonus[c];for(const[p,b]of Object.entries(d))for(let I=0;I<b;I++){const E=C(p);E.classList.add("holding-bonus-icon"),l.appendChild(E)}}),["neutral","player","comp1","comp2"].forEach(c=>{const l=document.getElementById(`ladder-${c}`);l.innerHTML="",a.ladder[c].forEach(d=>{l.appendChild(m(d.toStringShort()))})});const n=document.getElementById("penultimate-display"),r=document.getElementById("dead-display");n.innerHTML="",r.innerHTML="",a.penultimate.forEach(c=>n.appendChild(m(c.toStringShort()))),a.dead.forEach(c=>r.appendChild(m(c.toStringShort()))),document.getElementById("scores").innerText=`You: ${a.scores.player}, comp 1: ${a.scores.comp1}, comp 2: ${a.scores.comp2}`,document.getElementById("scores-previous").innerText=`prev: (You: ${a.scores_previous.player}, comp 1: ${a.scores_previous.comp1}, comp 2: ${a.scores_previous.comp2})`,document.getElementById("escalations").innerText=`Escalations: ${a.escalations} (hand #${a.hand_number})`;const s=document.getElementById("trumps");s.innerHTML="",s.appendChild(C(a.trumps?a.trumps.toStringShort():""));const i=document.getElementById("advance");i.innerHTML="",i.appendChild(C(a.advance));let o;switch(a.game_state){case"playCard":if(a.whose_turn==="player")break;await S(700),o=P(a),f(o);break;case"trickComplete":await S(1700),o=P(a),f(o);break;case"handComplete":await S(3e3),o=P(a),f(o);break;default:console.log(`Error: Switching and failing: ${a.game_state}`)}}function S(a){return new Promise(e=>setTimeout(e,a))}function P(a){return a.increment()}window.onload=()=>{const a=new $(["Andy","Randy1","Randy2"]);f(a.getGameStateForUI())};
